SHELL = /bin/bash

SRCS = ft_utils.c 
SRCS += ft_init.c 
SRCS += ft_parsing.c 
SRCS += ft_quotes.c
SRCS += ft_free.c
SRCS += ft_logo.c
SRCS += ft_pipex.c
SRCS += ft_signal.c
SRCS += ft_split_keep.c
SRCS += ft_split_leave.c
SRCS += ft_split_lquotes.c
SRCS += main.c
SRCS += pipex_utils.c
SRCS += ft_heredoc.c
SRCS += ft_exec_built_in.c


SRCS += ft_cmd_test_buildin.c
SRCS += ft_create_env.c
SRCS += ft_cmd_env.c
SRCS += ft_cmd_echo.c
SRCS += ft_cmd_export.c
SRCS += ft_cmd_pwd.c
SRCS += ft_cmd_cd.c
SRCS += ft_cmd_unset.c
SRCS += ft_cmd_exit.c


# SRC_PATH += /libft/src
SRC_PATH += ./minishell_src/Build-in/
SRC_PATH += ./minishell_src/Execution/
SRC_PATH += ./minishell_src/Free/
SRC_PATH += ./minishell_src/Parsing/
SRC_PATH += ./minishell_src/Signal/
SRC_PATH += ./minishell_src/Start/
SRC_PATH += ./minishell_src/Utiles/
SRC_PATH += ./minishell_src/Other/
SRC_PATH += ./minishell_src/
# SRC_PATH += /pipex


OBJS = ${patsubst %.c, ${OBJS_PATH}/%.o, ${SRCS}}
OBJS_PATH = ./minishell_src/_Objet


HEAD_PATH += -I ./minishell_src/_Include
HEAD_PATH += -I ./libft/inc

LIB += -L ./libft -lft
# LIB += -L ./pipex -lpipex
LIB += -lreadline

NAME = minishell
CC = cc

CFLAGS += -Wall -Werror -Wextra
CFLAGS += -g



vpath %.c ${SRC_PATH}
vpath %.h ${HEAD_PATH}

all: ${NAME}

run: all
# @	clear
	@	./${NAME}

valgrind: all
	valgrind --track-fds=yes --suppressions=assets/ignore_readline_leaks.supp  ./${NAME}


NOCOLOR='\033[0m'
RED='\033[0;31m'
GREEN='\033[0;32m'
ORANGE='\033[0;33m'
BLUE='\033[0;34m'
PURPLE='\033[0;35m'
CYAN='\033[0;36m'
LIGHTGRAY='\033[0;37m'

DARKGRAY='\033[1;30m'
LIGHTRED='\033[1;31m'
LIGHTGREEN='\033[1;32m'
LIGHTBLUE='\033[1;34m'
LIGHTPURPLE='\033[1;35m'
LIGHTCYAN='\033[1;36m'
YELLOW='\033[1;33m'
WHITE='\033[1;37m'




${OBJS}: ${OBJS_PATH}/%.o: %.c Makefile minishell.h
	@	$(MAKE) --no-print-directory -s -C libft
#	 @	$(MAKE) --no-print-directory -s -C pipex
	@	mkdir -p ${OBJS_PATH}
	@	$(COLORCOMPIL)
	@	${CC} ${CFLAGS} -c $< -o $@ ${HEAD_PATH}

${NAME}:  ${OBJS}
	@	${CC} ${CFLAGS} -o ${NAME} ${OBJS} ${LIB} ${HEAD_PATH}
	@	echo -ne "\r\033[2K" $(LIGHTGREEN) "\t$(NAME) OK" "\033[0m" "\n"





clean:
	@	echo -ne "\r\033[2K" $(YELLOW) "Cleaning\n\n"$(NC)
	@	rm -rf ${OBJS_PATH}
	@	$(MAKE) --no-print-directory -s clean -C libft
	@	echo -ne "\r\033[2K" $(GREEN) "\tLibft cleaned\n"$(NC)


fclean: clean
	@	rm -f ${NAME}
	@	$(MAKE) --no-print-directory -s fclean -C libft
	@	echo -ne "\r\033[2K" $(GREEN) "\t$(NAME) cleaned\n"$(NC)"\n"




re: fclean
	@	echo -ne "\r\033[2K" $(YELLOW) "Rebuilding..."$(NC)"\n""\n"
# @	echo ""$(YELLOW) "\nRebuilding...\n" $(NC)
	@	$(MAKE) -s


.PHONY: re clean fclean 

NOCOLOR='\033[0m'
RED='\033[0;31m'
GREEN='\033[0;32m'
ORANGE='\033[0;33m'
BLUE='\033[0;34m'
PURPLE='\033[0;35m'
CYAN='\033[0;36m'
LIGHTGRAY='\033[0;37m'

DARKGRAY='\033[1;30m'
LIGHTRED='\033[1;31m'
LIGHTGREEN='\033[1;32m'
LIGHTBLUE='\033[1;34m'
LIGHTPURPLE='\033[1;35m'
LIGHTCYAN='\033[1;36m'
YELLOW='\033[1;33m'
WHITE='\033[1;37m'


ifndef COLORCOMPIL
COLORCOMPIL = \
	if [ "$(shell test $P -lt 33; echo $$?)" = "0" ]; then \
    	echo -ne "\r\033[2K" $(LIGHTRED) "[$(P)%] "$(DARKGRAY) "Compiling MiniShell" $(WHITE) "$<"; \
	else \
		if [ "$(shell test $P -lt 66; echo $$?)" = "0" ]; then \
    		echo -ne "\r\033[2K" $(YELLOW) "[$(P)%]" $(DARKGRAY) "Compiling MiniShell" $(WHITE) "$<"; \
		else \
       		echo -ne "\r\033[2K" $(LIGHTGREEN) "[$(P)%]" $(DARKGRAY) "Compiling MiniShell" $(WHITE) "$<"; \
		fi \
	fi
T := $(words $(SRCS))
N := x
C = $(words $N)$(eval N := x $N)
P = `expr $C '*' 100 / $T / 5`
endif{
    ignore_readline_leaks
    Memcheck:Leak
    ...
    fun:readline
}
{
    ignore_readline_leaks
    Memcheck:Leak
    ...
    fun:add_history
}SHELL = /bin/bash


LIBC =			\
		ft_atoi.c ft_bzero.c ft_calloc.c ft_isalnum.c ft_isalpha.c \
		ft_isascii.c ft_isdigit.c ft_isprint.c ft_memchr.c \
		ft_memcmp.c ft_memcpy.c ft_memmove.c ft_memset.c ft_strchr.c \
		ft_strdup.c ft_strlcat.c ft_strlcpy.c ft_strlen.c ft_strncmp.c \
		ft_strnstr.c ft_strrchr.c ft_tolower.c ft_toupper.c ft_strcmp.c \
		ft_strrjoin.c ft_gen_randstr.c

ADDITIONAL =	\
		ft_itoa.c ft_putchar_fd.c ft_putendl_fd.c ft_putnbr_fd.c ft_putstr_fd.c \
		ft_split.c ft_strjoin.c ft_strmapi.c ft_strtrim.c ft_substr.c ft_striteri.c

PRINTF =		\
		ft_printf_pc_id.c ft_printf_pc_p.c ft_printf_pc_u.c ft_printf_pc_x.c ft_printf.c

GETNEXTLINE =	\
		get_next_line_utils.c get_next_line.c

BONUS = 		\
		ft_lstnew.c ft_lstadd_front.c ft_lstsize.c ft_lstlast.c ft_lstadd_back.c  \
		ft_lstdelone.c ft_lstclear.c ft_lstiter.c ft_lstmap.c

SRCS_PATH = ./src
SRCS = ${LIBC} ${ADDITIONAL} ${PRINTF} ${GETNEXTLINE} ${BONUS}

OBJS_PATH = ./obj
OBJS = ${patsubst %.c, ${OBJS_PATH}/%.o, ${SRCS}}

INCLUDE = -I ${SRCS_PATH}/inc

LIB = libft.a
CC = cc
CFLAGS = -g -Wall -Werror -Wextra -I ./


vpath %.c ${SRCS_PATH}

all: 	${LIB}

${OBJS}: ${OBJS_PATH}/%.o: %.c Makefile ${SRCS_PATH}/inc/SuperLibft.h
	@	mkdir -p ${OBJS_PATH}
	@	$(COLORCOMPIL)
	@	${CC} ${CFLAGS} -c $< -o $@ ${INCLUDE}

${LIB}:	${OBJS}
	@	ar -rsc ${LIB} ${OBJS}
	@	echo -ne "\r\033[2K" $(LIGHTGREEN) "\t$(LIB) OK"$(NC)"\n""\n"


clean:	
	@	rm -rf ${OBJS_PATH}

fclean:	clean;
	@	rm -rf ${LIB}

re:	fclean all

.PHONY: all clean fclean re bonus


NC='\033[0m'
RED='\033[0;31m'
GREEN='\033[0;32m'
ORANGE='\033[0;33m'
BLUE='\033[0;34m'
PURPLE='\033[0;35m'
CYAN='\033[0;36m'
LIGHTGRAY='\033[0;37m'

DARKGRAY='\033[1;30m'
LIGHTRED='\033[1;31m'
LIGHTGREEN='\033[1;32m'
LIGHTBLUE='\033[1;34m'
LIGHTPURPLE='\033[1;35m'
LIGHTCYAN='\033[1;36m'
YELLOW='\033[1;33m'
WHITE='\033[1;37m'


ifndef COLORCOMPIL
COLORCOMPIL = \
	if [ "$(shell test $P -lt 33; echo $$?)" = "0" ]; then \
    	echo -ne "\r\033[2K" $(LIGHTRED) "[$(P)%] "$(DARKGRAY) "Compiling Libft" $(WHITE) "$<"; \
	else \
		if [ "$(shell test $P -lt 66; echo $$?)" = "0" ]; then \
    		echo -ne "\r\033[2K" $(YELLOW) "[$(P)%]" $(DARKGRAY) "Compiling Libft" $(WHITE) "$<"; \
		else \
       		echo -ne "\r\033[2K" $(LIGHTGREEN) "[$(P)%]" $(DARKGRAY) "Compiling Libft" $(WHITE) "$<"; \
		fi \
	fi
T := $(words $(SRCS))
N := x
C = $(words $N)$(eval N := x $N)
P = `expr $C '*' 100 / $T / 5`

#include "SuperLibft.h"

int	ft_atoi(const char *str)
{
	int	i;
	int	signe;
	int	nb;

	signe = 1;
	i = 0;
	nb = 0;
	while (('\t' <= str[i] && str[i] <= '\r') || (str[i] == ' '))
	{
		i++;
	}
	if (str[i] == '+')
		i++;
	else if (str[i] == '-')
	{
		i++;
		signe = -signe;
	}
	while ('0' <= str[i] && str[i] <= '9')
	{
		nb = nb * 10 + str[i] - 48;
		i++;
	}
	return (nb * signe);
}


#include "SuperLibft.h"

void	ft_bzero(void *s, size_t n)
{
	char	*str;

	str = s;
	while (n)
	{
		*str = '\0';
		str++;
		n--;
	}
}

#include "SuperLibft.h"

void	*ft_calloc(size_t nbitems, size_t size)
{
	size_t	count;
	size_t	tmax;
	char	*str;

	tmax = (size_t) -1;
	if (size != 0 && nbitems > (tmax / size))
		return (NULL);
	count = nbitems * size;
	str = malloc(nbitems * size);
	if (str == NULL)
		return (NULL);
	else
	{
		while (count)
		{
			str[count - 1] = '\0';
			count--;
		}
	}
	return (str);
}


#include "SuperLibft.h"

static int	_buf_iteration(int fd, char *buf, size_t len)
{
	size_t		i;

	i = 0;
	while (i < len)
	{
		while (!ft_isalpha(buf[i]) && !ft_isdigit(buf[i]) && \
		buf[i] != '_' && buf[i] != '-' && buf[i] != '+')
		{
			if (read(fd, buf + i, 1) != 1)
				return (0);
		}
		i++;
	}
	return (1);
}

char	*ft_randomstr(char *prefix, char *suffix, size_t len)
{
	int			fd;
	char		*buf;
	char		*str;

	fd = open("/dev/urandom", O_RDONLY);
	if (fd == -1)
		return (NULL);
	buf = ft_calloc(sizeof(char), len + 1);
	if (!buf)
		return (close(fd), NULL);
	if (!_buf_iteration(fd, buf, len))
		return (close(fd), free(buf), NULL);
	close(fd);
	str = ft_strrjoin(prefix, buf, suffix);
	free(buf);
	return (str);

#include "SuperLibft.h"

int	ft_isalnum(int str)
{	
	if (!((47 < str && str < 58) || (64 < str && str < 91)
			|| (96 < str && str < 123)))
		return (0);
	return (1);
}

{
	int i = 0;
	while (i<127)
	{
		printf("%d \t", isalnum(i));
		printf("%d \t %c\n", ft_isalnum(i),i);
		i++;
	}
}*/

#include "SuperLibft.h"

int	ft_isalpha(int str)
{	
	if (!((64 < str && str < 91) || (96 < str && str < 123)))
		return (0);
	return (1);
}

{
	int i = 0;
	while (i<127)
	{
		printf("%d\n", isalpha(i));
		printf("%d\n\n\n", ft_isalpha(i));
		i++;
	}
}*/

#include "SuperLibft.h"

int	ft_isascii(int str)
{	
	if (!(-1 < str && str < 128))
		return (0);
	return (1);
}

{
	int i = -4;
	while (i<130)
	{
		printf("%d \t", isascii(i));
		printf("%d \t %c\n", ft_isascii(i),i);
		i++;
	}
}*/

#include "SuperLibft.h"

int	ft_isdigit(int str)
{	
	if (!((47 < str && str < 58)))
		return (0);
	return (1);
}

{
	int i = 0;
	while (i<127)
	{
		printf("%d \t", isdigit(i));
		printf("%d \t %c\n\n", ft_isdigit(i),i);
		i++;
	}
}*/

#include "SuperLibft.h"

int	ft_isprint(int str)
{	
	if (!(31 < str && str < 127))
		return (0);
	return (1);
}

{
	int i = -2;
	while (i<129)
	{
		printf("%d \t", isprint(i));
		printf("%d \t %c\n", ft_isprint(i),i);
		i++;
	}
}*/

#include "SuperLibft.h"

static char	*ft_nbr_to_str(char *str, int n, int signe, int size)
{
	int	i;

	i = 0;
	if (signe == -1)
	{
		str[i++] = '-';
	}
	while (n > 0)
	{
		str[size] = n % 10 + 48;
		n = n / 10;
		size--;
	}
	return (str);
}

static	char	*ft_itoa_zero(void)
{
	char	*str;

	str = malloc(sizeof(char) * 2);
	if (str == NULL)
		return (NULL);
	str[0] = '0';
	str[1] = '\0';
	return (str);
}

static char	*ft_min_int(int n)
{
	char	*str;

	if (n == 0)
		return (ft_itoa_zero());
	str = malloc(sizeof(char) * 12);
	if (str == NULL)
		return (NULL);
	str[0] = '-';
	str[1] = '2';
	str[2] = '1';
	str[3] = '4';
	str[4] = '7';
	str[5] = '4';
	str[6] = '8';
	str[7] = '3';
	str[8] = '6';
	str[9] = '4';
	str[10] = '8';
	str[11] = '\0';
	return (str);
}

char	*ft_itoa(int n)
{
	char	*nbr;
	int		signe;
	int		size;
	int		ndb;

	signe = 1;
	size = 0;
	if (n == -2147483648 || n == 0)
		return (ft_min_int(n));
	if (n < 0)
	{
		signe = -1;
		size = 1;
		n = -n ;
	}
	ndb = n;
	while (n > 0)
	{
		n = n / 10;
		size++;
	}
	nbr = malloc(sizeof(char) * (size + 1));
	nbr[size] = '\0';
	return (ft_nbr_to_str(nbr, ndb, signe, --size));
}


#include "SuperLibft.h"

void	ft_lstadd_back(t_list **lst, t_list *new)
{
	if (lst == NULL)
		return ;
	if (*lst == NULL)
		*lst = new;
	else
		ft_lstlast(*lst)->next = new;
}

#include "SuperLibft.h"

void	ft_lstadd_front(t_list **lst, t_list *new)
{
	new->next = *lst;
	*lst = new;
}

#include "SuperLibft.h"

void	ft_lstclear(t_list **lst, void (*del)(void*))
{
	t_list	*adresse;
	t_list	*adresseback;

	adresse = *lst;
	if (lst == NULL && *lst == NULL)
		return ;
	while (adresse->next != NULL)
	{
		if ((*del) != NULL)
			(*del)(adresse->content);
		adresseback = adresse;
		adresse = adresse->next;
		free(adresseback);
	}
	if ((*del) != NULL)
		(*del)(adresse->content);
	free(adresse);
	*lst = NULL;
}

#include "SuperLibft.h"

void	ft_lstdelone(t_list *lst, void (*del)(void*))
{
	if (lst == NULL)
		return ;
	if ((*del) != NULL)
		(*del)(lst->content);
	free(lst);
}

#include "SuperLibft.h"

void	ft_lstiter(t_list *lst, void (*f)(void *))
{
	t_list	*adresse;

	adresse = lst;
	while (adresse->next != NULL)
	{
		(*f)(adresse->content);
		adresse = adresse->next;
	}
	(*f)(adresse->content);
}

#include "SuperLibft.h"

t_list	*ft_lstlast(t_list	*lst)
{
	t_list	*adresse;

	adresse = lst;
	if (lst == 0)
		return (0);
	while (adresse->next != NULL)
		adresse = adresse->next;
	return (adresse);
}

#include "SuperLibft.h"

t_list	*ft_lstmap(t_list *lst, void *(*f)(void *), void (*del)(void *))
{
	t_list	*new;
	t_list	*adretour;

	if (!lst || !(*f) || !(*del))
		return (NULL);
	new = ft_lstnew((*f)(lst->content));
	adretour = new;
	while (lst->next != NULL && lst)
	{
		if (!new)
			return (NULL);
		new->next = ft_lstnew((*f)(lst->next->content));
		new = new->next;
		lst = lst->next;
	}
	return (adretour);
}

#include "SuperLibft.h"

t_list	*ft_lstnew(void *content)
{
	t_list	*new;

	new = malloc(sizeof(t_list));
	if (new == NULL)
		return (NULL);
	new->content = content;
	new->next = NULL;
	return (new);
}

#include "SuperLibft.h"

int	ft_lstsize(t_list *lst)
{
	int		i;
	t_list	*adresse;

	i = 1;
	adresse = lst;
	if (lst == 0)
		return (0);
	while (adresse->next != 0)
	{
		adresse = adresse->next;
		i++;
	}
	return (i);
}

#include "SuperLibft.h"

void	*ft_memchr(const void *s, int c, size_t n)
{
	size_t			i;
	unsigned char	*str;

	str = (unsigned char *)s;
	i = 0;
	while (n)
	{
		if (str[i] == (unsigned char)c)
			return (&str[i]);
		n--;
		i++;
	}
	return (NULL);
}


#include "SuperLibft.h"

int	ft_memcmp(const void *s1, const void *s2, size_t n)
{
	size_t				i;
	unsigned char		*ptr1;
	unsigned char		*ptr2;

	i = 0;
	ptr1 = ((unsigned char *)s1);
	ptr2 = ((unsigned char *)s2);
	while (i < n)
	{
		if (ptr1[i] != ptr2[i])
			return (ptr1[i] - ptr2[i]);
		i++;
	}
	return (0);
}


#include "SuperLibft.h"

void	*ft_memcpy(void *dest, const void *src, size_t n)
{
	size_t	i;

	i = 0;
	while (n)
	{
		*((unsigned char *)dest + i) = *((unsigned char *)src + i);
		i++;
		n--;
	}
	return (dest);
}

int main() {
  
    int array [] = { 54, 85, 20, 63, 21 };
    int * copy = NULL;
    int length = sizeof( int ) * 5;
       
    copy = (int *) malloc( length );
    ft_memcpy( copy, array, length );
	memcpy( copy, array, length );
        

    for( length=0; length<5; length++ ) {
        printf( "%d ", copy[ length ] );
    }
    printf( "\n" );
        
    free( copy );
    
    return EXIT_SUCCESS;

#include "SuperLibft.h"

void	*ft_memmove(void *dest, const void *src, size_t n)
{
	size_t			i;
	unsigned long	adresse1;
	unsigned long	adresse2;

	i = 0;
	adresse1 = (unsigned long) src;
	adresse2 = (unsigned long) dest;
	if (adresse1 < adresse2)
	{
		while (n)
		{
			*((unsigned char *)dest + n - 1) = *((unsigned char *)src + n - 1);
			n--;
		}
	}
	else
	{
		while (n)
		{
			*((unsigned char *)dest + i) = *((unsigned char *) src + i);
			n--;
			i++;
		}
	}
	return (dest);
}

#include "SuperLibft.h"

void	*ft_memset(void *b, int c, size_t len)
{
	char	*str;

	str = b;
	while (len)
	{
		*str = (unsigned char)c;
		str++;
		len--;
	}
	return (b);
}
{

    void *ptr[20] ;
    int value = 50;
    int n = 5;
	int test = 50;
    printf("%s\n\n", ft_memset(ptr, value, n));
	printf("%s", memset(ptr, value, test));

#include "SuperLibft.h"

int	ft_writechar(char ch, int nbrch)
{
	write(1, &ch, 1);
	nbrch++;
	return (nbrch);
}

int	ft_writestr(char *str, int nbrch)
{
	int	i;

	i = 0;
	if (str == NULL)
		return (ft_writestr("(null)", nbrch));
	while (str[i] != '\0')
	{
		write(1, &str[i], 1);
		i++;
		nbrch++;
	}
	return (nbrch);
}

int	ft_verif_pc(const char *str)
{
	if (str[1] == 'c')
		return (1);
	else if (str[1] == 's')
		return (1);
	else if (str[1] == 'p')
		return (1);
	else if (str[1] == 'd')
		return (1);
	else if (str[1] == 'i')
		return (1);
	else if (str[1] == 'u')
		return (1);
	else if (str[1] == 'x')
		return (1);
	else if (str[1] == 'X')
		return (1);
	else if (str[1] == '%')
		return (1);
	else
		return (2);
}

int	ft_print_pourcent(const char *str, int nbrch, va_list *list)
{
	if (str[1] == 'c')
		nbrch = ft_writechar(va_arg(*list, int), nbrch);
	if (str[1] == 's')
		nbrch = ft_writestr(va_arg(*list, char *), nbrch);
	if (str[1] == 'p')
		nbrch = ft_pc_p(va_arg(*list, unsigned long), nbrch);
	if (str[1] == 'd')
		nbrch = ft_pc_id(va_arg(*list, int), nbrch);
	if (str[1] == 'i')
		nbrch = ft_pc_id(va_arg(*list, int), nbrch);
	if (str[1] == 'u')
		nbrch = ft_pc_u(va_arg(*list, unsigned int), nbrch);
	if (str[1] == 'x')
		nbrch = ft_pc_x(va_arg(*list, long), "0123456789abcdef", nbrch);
	if (str[1] == 'X')
		nbrch = ft_pc_x(va_arg(*list, long), "0123456789ABCDEF", nbrch);
	if (str[1] == '%')
		nbrch = ft_writechar('%', nbrch);
	return (nbrch);
}

int	ft_printf(const char *str, ...)
{
	int		i;
	int		nbrch;
	va_list	list;

	i = -1;
	nbrch = 0;
	va_start(list, str);
	if (str == NULL)
		return (-1);
	while (str[++i] != '\0')
	{
		if (str[i] == '%' && str[i + 1] == '\0')
			return (-1);
		if (str[i] == '%' && ft_verif_pc(&str[i]) == 2)
			nbrch = ft_writechar('%', nbrch);
		else if (str[i] == '%')
			nbrch = ft_print_pourcent(&str[i++], nbrch, &list);
		else
			nbrch = ft_writechar(str[i], nbrch);
	}
	va_end(list);
	return (nbrch);
}

#include "SuperLibft.h"


void	ft_putchar_pc_idu(char c)
{
	c = c + 48;
	write(1, &c, 1);
}

void	ft_putnbr_pc_id(int nb)
{
	if (nb < -2147483647)
	{
		write(1, "-", 1);
		write(1, "2147483648", 10);
		return ;
	}	
	if (nb < 0)
	{
		write(1, "-", 1);
		nb = -nb;
	}	
	if (nb < 10)
		ft_putchar_pc_idu(nb);
	else
	{
		ft_putnbr_pc_id(nb / 10);
		ft_putnbr_pc_id(nb % 10);
	}
}

int	ft_pc_id(int nbr, int nbrch)
{
	ft_putnbr_pc_id(nbr);
	if (nbr < -2147483647)
		return (nbrch + 11);
	if (nbr <= 0)
	{
		nbrch++;
		nbr = -nbr;
	}
	while (0 < nbr)
	{
		nbr = nbr / 10;
		nbrch++;
	}
	return (nbrch);
}

#include "SuperLibft.h"

int	ft_pc_p(unsigned long nbr, int nbrch)
{
	if (nbr == 0)
	{
		ft_writestr("(nil)", nbrch);
		return (nbrch + 5);
	}
	nbrch = ft_writestr("0x", nbrch);
	ft_print_pc_p_base(nbr, nbrch);
	return (ft_len_nbr_pc_p(nbr, nbrch));
}

int	ft_print_pc_p_base(unsigned long nbr, int nbrch)
{
	char	*base;

	base = "0123456789abcdef";
	if (nbr < 16)
	{
		nbrch = nbrch + ft_writechar(base[nbr], nbrch);
	}
	else
	{
		ft_print_pc_p_base(nbr / 16, nbrch);
		ft_print_pc_p_base(nbr % 16, nbrch);
	}
	return (nbrch);
}

int	ft_len_nbr_pc_p(unsigned long nbr, int nbrch)
{	
	if (nbr == 0)
		return (1);
	while (0 < nbr)
	{
		nbr = nbr / 16;
		nbrch++;
	}
	return (nbrch);
}

#include "SuperLibft.h"

void	ft_putnbr_pc_u(unsigned int nb)
{
	if (nb < 10)
		ft_putchar_pc_idu(nb);
	else
	{
		ft_putnbr_pc_u(nb / 10);
		ft_putnbr_pc_u(nb % 10);
	}
}

int	ft_pc_u(unsigned int nbr, int nbrch)
{
	ft_putnbr_pc_u(nbr);
	if (nbr <= 0)
		nbrch++;
	while (0 < nbr)
	{
		nbr = nbr / 10;
		nbrch++;
	}
	return (nbrch);
}

#include "SuperLibft.h"

void	ft_print_base_pc_x(unsigned int nbr, char *base)
{
	if (nbr < 16)
		write (1, &base[nbr], 1);
	else
	{
		ft_print_base_pc_x(nbr / 16, base);
		ft_print_base_pc_x(nbr % 16, base);
	}
}

int	ft_pc_x(long nbr, char *base, int nbrch)
{
	unsigned int	nb;

	nb = (unsigned int) nbr;
	ft_print_base_pc_x(nb, base);
	return (ft_len_nbr_pc_x(nb, nbrch));
}

int	ft_len_nbr_pc_x(unsigned int nbr, int nbrch)
{	
	if (nbr == 0)
		return (nbrch + 1);
	while (0 < nbr)
	{
		nbr = nbr / 16;
		nbrch++;
	}
	return (nbrch);
}

#include "SuperLibft.h"

void	ft_putchar_fd(char c, int fd)
{
	write(fd, &c, 1);
}

#include "SuperLibft.h"

void	ft_putendl_fd(char *s, int fd)
{
	int		i;
	char	c;

	i = 0;
	while (s[i])
	{
		write(fd, &s[i], 1);
		i++;
	}
	c = '\n';
	write(fd, &c, 1);
}

#include "SuperLibft.h"

static void	ft_putnbr(int c, int fd)
{
	c = c + 48;
	write(fd, &c, 1);
}

void	ft_putnbr_fd(int nb, int fd)
{
	if (nb < -2147483647)
	{
		write(fd, "-", 1);
		write(fd, "2147483648", 10);
		return ;
	}	
	if (nb < 0)
	{
		write(fd, "-", 1);
		nb = -nb;
	}	
	if (nb < 10)
		ft_putnbr(nb, fd);
	else
	{
		ft_putnbr_fd(nb / 10, fd);
		ft_putnbr_fd(nb % 10, fd);
	}
}


#include "SuperLibft.h"

void	ft_putstr_fd(char *s, int fd)
{
	int	i;

	i = 0;
	while (s[i])
	{
		write(fd, &s[i], 1);
		i++;
	}
}


#include "SuperLibft.h"

static size_t	count_words(char const *s, char c)
{
	size_t	words;
	size_t	i;

	words = 0;
	i = 0;
	while (s[i])
	{
		if (s[i] != c && (s[i + 1] == c || s[i + 1] == '\0'))
			words++;
		i++;
	}
	return (words);
}

static void	fill_tab(char *new, char const *s, char c)
{
	size_t	i;

	i = 0;
	while (s[i] && s[i] != c)
	{
		new[i] = s[i];
		i++;
	}
	new[i] = '\0';
}

void	free_tabstr(char **tab)
{
	size_t	i;

	if (!tab)
		return ;
	i = 0;
	while (tab[i])
	{
		free(tab[i]);
		i++;
	}
	free(tab);
}

static int	set_mem(char **tab, char const *s, char c)
{
	size_t	count;
	size_t	index;
	size_t	i;

	index = 0;
	i = 0;
	while (s[index])
	{
		count = 0;
		while (s[index + count] && s[index + count] != c)
			count++;
		if (count > 0)
		{
			tab[i] = malloc(sizeof(char) * (count + 1));
			if (!tab[i])
				return (free_tabstr(tab), 0);
			fill_tab(tab[i], (s + index), c);
			i++;
			index = index + count;
		}
		else
			index++;
	}
	tab[i] = 0;
	return (1);
}

char	**ft_split(char const *s, char c)
{
	size_t	words;
	char	**tab;

	words = count_words(s, c);
	tab = malloc(sizeof(char *) * (words + 1));
	if (!tab)
		return (NULL);
	set_mem(tab, s, c);
	return (tab);
}

#include "SuperLibft.h"

char	*ft_strchr(char *str, int lettre)
{
	int				i;
	unsigned char	ch;

	i = 0;
	ch = (unsigned char) lettre;
	while (str[i] != ch)
	{
		if (str[i] == '\0')
			return (NULL);
		i++;
	}
	return (&str[i]);
}

#include "SuperLibft.h"

int	ft_strcmp(const char *s1, const char *s2)
{
	size_t	i;

	i = 0;
	if (s1 == NULL || s2 == NULL)
		return (-42);
	while (s1[i] && s2[i] && s1[i] == s2[i])
		i++;
	return ((unsigned char) s1[i] - (unsigned char) s2[i]);

#include "SuperLibft.h"

char	*ft_strdup(char *str)
{
	int		i;
	char	*dup;

	i = 0;
	while (str[i] != '\0')
		i++;
	dup = malloc(sizeof(char) * i + 1);
	i = 0;
	while (str[i] != '\0')
	{
		dup[i] = str[i];
		i++;
	}
	dup[i] = '\0';
	return (dup);
}


#include "SuperLibft.h"

void	ft_striteri(char *s, void (*f)(unsigned int, char*))
{
	int	i;

	i = 0;
	while (s[i] != '\0')
	{
		(*f)(i, s + i);
		i++;
	}
}

#include "SuperLibft.h"

char	*ft_strjoin(char const *s1, char const *s2)
{
	char	*str;
	int		i;
	int		j;

	i = 0;
	j = 0;
	str = malloc(sizeof(char) * (ft_strlen(s1) + ft_strlen(s2) + 1));
	if (str == NULL)
		return (NULL);
	while (s1[i] != '\0')
	{
		str[j] = s1[i];
		i++;
		j++;
	}
	i = 0;
	while (s2[i] != '\0')
	{
		str[j] = s2[i];
		i++;
		j++;
	}
	str[j] = '\0';
	return (str);
}


#include "SuperLibft.h"

size_t	ft_strlcat(char *dst, const char *src, size_t size)
{
	size_t	i;
	size_t	j;
	size_t	dest_len;
	size_t	src_len;

	src_len = ft_strlen((char *)src);
	dest_len = ft_strlen((char *)dst);
	j = dest_len;
	i = 0;
	if (dest_len < size - 1 && size > 0)
	{
		while (src[i] && (dest_len + i < size - 1))
		{
			dst[j] = src[i];
			j++;
			i++;
		}
		dst[j] = 0;
	}
	if (dest_len >= size)
		dest_len = size;
	return (dest_len + src_len);
}

#include "SuperLibft.h"
#include <stdio.h>
#include <string.h>

size_t	ft_strlcpy(char *dst, const char *src, size_t size)
{
	size_t	i;

	i = -1;
	if (src == NULL || dst == NULL)
		return (0);
	if (size == 0)
		return (ft_strlen(src));
	while (++i + 1 < size && src[i] != '\0')
		dst[i] = src[i];
	dst[i] = '\0';
	return (ft_strlen(src));
}

#include "SuperLibft.h"

size_t	ft_strlen(const char *str)
{
	size_t	i;

	i = 0;
	while (str && !(str[i] == '\0'))
	{
		i++;
	}
	return (i);
}

#include "SuperLibft.h"

char	*ft_strmapi(char const *s, char (*f)(unsigned int, char))
{
	unsigned int	i;
	char			*str;

	i = 0;
	while (s[i])
		i++;
	str = malloc(sizeof(char) * i + 1);
	str[i] = '\0';
	if (str == NULL)
		return (NULL);
	i = 0;
	while (s[i] != '\0')
	{
		str[i] = (*f)(i, s[i]);
		i++;
	}
	return (str);
}


#include "SuperLibft.h"

int	ft_strncmp(const char *s1, const char *s2, size_t n)
{
	size_t	i;

	i = 0;
	while ((s1[i] || s2[i]) && i < n)
	{
		if (s1[i] != s2[i])
			return ((unsigned char)s1[i] - (unsigned char)s2[i]);
		i++;
	}
	return (0);
}


#include "SuperLibft.h"

char	*ft_strnstr(const char *src, const char *cmp, size_t n)
{
	size_t	i;
	size_t	j;
	size_t	k;
	char	*str;

	i = 0;
	j = 0;
	str = (char *) src;
	while (src[i] != '\0' || i == 0)
	{
		k = i;
		while (src[k] == cmp[j] && cmp[j] != '\0')
		{
			k++;
			j++;
		}
		if (k > n)
			return (0);
		if (cmp[j] == '\0')
			return (&str[i]);
		i++;
		j = 0;
	}
	return (0);
}


#include "SuperLibft.h"

char	*ft_strrchr(const char *str, int lettre)
{
	int				i;
	unsigned char	ch;	

	i = ft_strlen(str);
	ch = (char) lettre;
	if (str == NULL)
		return (NULL);
	while (i >= 0)
	{
		if (str[i] == ch)
			return ((char *)&str[i]);
		i--;
	}
	return (NULL);
}


#include "SuperLibft.h"

static void	ft_strrjoin_bis(char *new, char const *s3)
{
	size_t	i;

	i = 0;
	while (s3 && s3[i])
	{
		new[i] = s3[i];
		i++;
	}
	new[i] = '\0';
}

char	*ft_strrjoin(char const *s1, char const *s2, char const *s3)
{
	char	*new;
	size_t	i;
	size_t	j;

	if (!s1 && !s2 && !s3)
		return (NULL);
	new = malloc(sizeof(char) * \
		(ft_strlen(s1) + ft_strlen(s2) + ft_strlen(s3) + 1));
	if (!new)
		return (NULL);
	i = 0;
	while (s1 && s1[i])
	{
		new[i] = s1[i];
		i++;
	}
	j = 0;
	while (s2 && s2[j])
	{
		new[i + j] = s2[j];
		j++;
	}
	ft_strrjoin_bis(new + i + j, s3);
	return (new);
}#include "SuperLibft.h"

static char	*find_begin(char const *s1, char const *set)
{
	size_t	i;
	size_t	j;
	int		in_set;

	in_set = 0;
	i = 0;
	j = 0;
	while (s1[i])
	{
		in_set = 0;
		j = 0;
		while (set[j])
		{
			if (s1[i] == set[j])
				in_set = 1;
			j++;
		}
		if (!in_set)
			break ;
		i++;
	}
	return ((char *) s1 + i);
}

static char	*find_end(char const *s1, char const *set, char const *begin)
{
	size_t	i;
	size_t	j;
	int		in_set;

	in_set = 0;
	i = ft_strlen(s1) - 1;
	j = 0;
	while (s1 + i >= begin)
	{
		in_set = 0;
		j = 0;
		while (set[j])
		{
			if (s1[i] == set[j])
				in_set = 1;
			j++;
		}
		if (!in_set)
			break ;
		i--;
	}
	if (s1 + i < begin)
		return ((char *) begin);
	return ((char *) s1 + i);
}

static char	*fill_str(char const *begin, char const *end)
{
	char	*new;
	size_t	i;

	new = malloc(sizeof(char) * (end - begin + 2));
	if (!new)
		return (NULL);
	i = 0;
	while (begin + i <= end)
	{
		new[i] = begin[i];
		i++;
	}
	new[i] = '\0';
	return (new);
}

char	*ft_strtrim(char const *s1, char const *set)
{
	char	*begin;
	char	*end;
	char	*new;

	begin = find_begin(s1, set);
	end = find_end(s1, set, s1);
	if (!s1[0] || end < begin)
	{
		new = malloc(sizeof(char) * 1);
		if (!new)
			return (NULL);
		new[0] = '\0';
	}
	else
		new = fill_str(begin, end);
	if (!new)
		return (NULL);
	return (new);
}

#include "SuperLibft.h"

char	*ft_substr(char const *s, unsigned int start, size_t len)
{
	char			*new;
	unsigned int	i;

	if (start >= ft_strlen(s))
		len = 0;
	else if (len > ft_strlen(s + start))
		len = ft_strlen(s + start);
	new = malloc(sizeof(char) * (len + 1));
	if (!new)
		return (NULL);
	i = 0;
	while (start + i < ft_strlen(s) && i < len)
	{
		new[i] = s[start + i];
		i++;
	}
	new[i] = '\0';
	return (new);

#include "SuperLibft.h"

int	ft_tolower(int character)
{
	if (64 < character && character < 91)
	{
		return (character + 32);
	}
	return (character);
}


#include "SuperLibft.h"

int	ft_toupper( int character )
{
	if ('a' <= character && character <= 'z')
	{
		return (character - 32);
	}
	return (character);
}


#include "./inc/get_next_line.h"

static t_fdList	*find_fdbegin(int fd, t_fdList **fd_list)
{
	t_fdList			*current;

	if (!(*fd_list))
		*fd_list = ftlst_new_fd(fd);
	if (!(*fd_list))
		return (NULL);
	current = *fd_list;
	while (current->next_fd && current->fd != fd)
		current = current->next_fd;
	if (current->fd != fd)
	{
		current->next_fd = ftlst_new_fd(fd);
		current = current->next_fd;
	}
	return (current);
}

static int	read_file(int fd, t_bufferList *begin, t_bufferList *current)
{
	int	readed;

	readed = 0;
	if (begin && end_of_line(begin->content))
		return (1);
	else if (begin && (begin->content[0]))
	{
		begin->next = ftlst_new_buffer();
		current = begin->next;
	}
	while (1)
	{
		readed = read(fd, current->content, BUFFER_SIZE);
		if (readed <= 0)
			break ;
		(current->content)[readed] = '\0';
		if (end_of_line(current->content))
			break ;
		current->next = ftlst_new_buffer();
		current = current->next;
	}
	if (!(begin->content[0]))
		return (0);
	return (1);
}

static char	*join_buffers(t_bufferList *current)
{
	char			*line;
	size_t			i;
	size_t			j;

	line = malloc(count_memory(current));
	if (!line)
		return (NULL);
	i = 0;
	while (current && current->content)
	{
		j = 0;
		while ((current->content)[j] && (i == 0 || line[i - 1] != '\n'))
			line[i++] = (current->content)[j++];
		current = current->next;
	}
	line[i] = '\0';
	return (line);
}

static void	clean_buffers(t_bufferList *current, t_fdList *current_fd)
{
	size_t			i;
	size_t			j;
	t_bufferList	*next;

	while (current->next)
	{
		next = current->next;
		free(current->content);
		free(current);
		current = next;
		current_fd->begin = next;
	}
	i = 0;
	while ((current->content)[i])
	{
		i++;
		if ((current->content)[i - 1] == '\n')
			break ;
	}
	j = 0;
	while ((current->content)[i])
		(current->content)[j++] = (current->content)[i++];
	(current->content)[j] = '\0';
}

char	*get_next_line(int fd)
{
	static t_fdList		*fd_list;
	t_fdList			*c_fd;
	t_bufferList		*begin;
	char				*line;

	if (fd < 0 || BUFFER_SIZE < 1)
		return (NULL);
	c_fd = find_fdbegin(fd, &fd_list);
	if (!c_fd)
		return (NULL);
	begin = c_fd->begin;
	if (read_file(fd, begin, begin))
		line = join_buffers(begin);
	else
		line = NULL;
	clean_buffers(begin, c_fd);
	fd_list = clean_fd_list(fd_list, c_fd);
	return (line);

#include "./inc/get_next_line.h"

t_bufferList	*ftlst_new_buffer(void)
{
	t_bufferList	*new;

	new = malloc(sizeof(t_bufferList));
	if (!new)
		return (NULL);
	new->content = malloc(BUFFER_SIZE + 1);
	if (!(new->content))
		return (free(new), NULL);
	(new->content)[0] = '\0';
	new->next = 0;
	return (new);
}

t_fdList	*ftlst_new_fd(int fd)
{
	t_fdList	*new;

	new = malloc(sizeof(t_fdList));
	if (!new)
		return (NULL);
	new->fd = fd;
	new->begin = ftlst_new_buffer();
	if (!(new->begin))
		return (free(new), NULL);
	new->next_fd = 0;
	return (new);
}

int	end_of_line(char *content)
{
	size_t	i;

	i = 0;
	while (content[i])
	{
		if (content[i] == '\n')
			return (1);
		i++;
	}
	return (0);
}

size_t	count_memory(t_bufferList *current)
{
	size_t	memory;
	size_t	i;

	memory = 1;
	while (current)
	{
		i = 0;
		while ((current->content)[i])
		{
			memory++;
			i++;
			if ((current->content)[i - 1] == '\n')
				break ;
		}
		if (i > 0 && (current->content)[i - 1] == '\n')
		{
			i++;
			break ;
		}
		current = current->next;
	}
	return (memory);
}

t_fdList	*clean_fd_list(t_fdList *fd_list, t_fdList *c_fd)
{
	t_fdList	*tmp;

	if (!((c_fd->begin->content)[0]))
	{
		free(c_fd->begin->content);
		free(c_fd->begin);
		if (fd_list == c_fd)
			fd_list = fd_list->next_fd;
		else
		{
			tmp = fd_list;
			while (tmp->next_fd && tmp->next_fd != c_fd)
				tmp = tmp->next_fd;
			if (tmp->next_fd)
				tmp->next_fd = tmp->next_fd->next_fd;
		}
		free(c_fd);
	}
	return (fd_list);
}#include "../_Include/minishell.h"
#include <sys/types.h>
#include <dirent.h>


int ft_strlen_char(char *str, char c)
{
	size_t	i;

	i = 0;
	while (str[i] != '\0' && str[i] != c)
		i++;
	return (i);
}

char *ft_just_cd(t_data *data)
{
    t_env *tmp;

    tmp = &data->env;
    while (tmp)
    {
        if (ft_strncmp(tmp->key, "HOME", ft_strlen(tmp->key)) == 0)
			return (ft_strdup(tmp->value));
        tmp = tmp->next;
    }
    return (NULL);
}

void	ft_change_pwd(t_data *data)
{
    t_env *tmp;

    tmp = &data->env;
	
	if (ft_strcmp(data->pwd, getcwd(NULL, 0)) == 0)
		return ;
	free(data->oldpwd);
	data->oldpwd = ft_strdup(data->pwd);	
	free(data->pwd);
	data->pwd = getcwd(NULL, 0);
    while (tmp)
    {
        if (ft_strncmp(tmp->key, "PWD", ft_strlen(tmp->key)) == 0)
		{
			free(tmp->value);
			tmp->value = ft_strdup(data->pwd);
		}
		if (ft_strncmp(tmp->key, "OLDPWD", ft_strlen(tmp->key)) == 0)
		{
			free(tmp->value);
			tmp->value = ft_strdup(data->oldpwd);
		}
        tmp = tmp->next;
    }
}

int	ft_cd(char **str, t_data *data)
{
	int i;
	char *path;
	path = NULL;

	if (ft_strstrlen(str) == 1)
	{
		path = ft_just_cd(data);
		if (chdir(path) != 0)
			return (perror(path), 1);
	}
	else
	{
		i = 1;
		while (str[i][0] == '-')
			i++;
		if (str[i] == 0)
			return (0);
		if (ft_strstrlen(str) != i + 1)
			return (ft_putstr_fd("cd: too many arguments\n", 1), 1);	
		if (chdir(str[i]) != 0)
		{
			ft_putstr_fd("cd: ", 1);
			ft_putstr_fd(str[i], 1);
			ft_putstr_fd(": ", 1);
			return (perror(path), 1);
		}
	}
	ft_change_pwd(data);
	return (0);
}
#include "../_Include/minishell.h"




int ft_verif_nl_echo(char *str)
{
	int i;
	int verif;

	i = 5;
	verif = 0;
	while (str[i])
	{
		if (str[i - 1] != '-' && str[i] == '-' && verif == 0)
			verif = 1;
		else if ((is_ws(str[i]) || (str[i + 1] == '\0' && str[i] == 'n')) && verif == 2)
			return (0);
		else if (str[i] == 'n' && verif <= 2)
			verif = 2;
		else 
			verif = 0;
		i++;
	}
	return (1);
}

int	ft_echo(char **cmd)
{
	int i;
	int nl;
	char *str;
	fprintf(stderr, "ICI C CARRE ECHO BG onela\n");
	str = ft_tab_to_str(cmd, ' ');
	i = 5;
	nl = ft_verif_nl_echo(str);
	while (str[i] && (str[i] == '-' || str[i] == 'n' || is_ws(str[i]) == 1))
	{
		if (str[i] == '-' && str[i+1] == '-')
			break ;
		i++;
	}
	while (str[i] && (str[i-1] == '-' || str[i-1] == 'n'))
		i--;
	ft_putstr_fd(str + i, 1);
	if (nl == 1)
	{
		ft_putstr_fd("\n", 1);
	}
	return (0);
}



	





int ft_env(t_data *data)
{
    t_env *tmp;

    tmp = &data->env;
    while (tmp)
    {
        if (tmp->printable == 1)
        {
            write(1, tmp->key, ft_strlen(tmp->key));
            write(1, "=", 1);
            write(1, tmp->value, ft_strlen(tmp->value));
            write(1, "\n", 1);
        }
        tmp = tmp->next;
    }
    return (0);
}



int	ft_exit(char **cmd, t_data *data)
{
	int i;
	int good_exit;

	i = 0;
	if (ft_strstrlen(cmd) == 1)
		exit(data->last_err_num);
	good_exit = 1;
	while (cmd[1][i])
	{
		if(ft_isdigit(cmd[1][i]) == 0)
			good_exit = 0;
		i++;
	}
	if (good_exit == 0)
	{
		ft_putstr_fd("exit: ", 1);
		ft_putstr_fd(cmd[1], 1);
		ft_putstr_fd(": numeric argument required\n", 1);
		exit(2);

	}
	else if (ft_strstrlen(cmd) == 3)
	{
		ft_putstr_fd("exit: too many arguments\n", 1);
		return (1);
	}
	else
	{
		good_exit = ft_atoi(cmd[1]);
		exit((unsigned char) good_exit);
	}
	return (0);
}




size_t	ft_strlen_WS(const char *str)
{
	size_t	i;

	i = 0;
	while (str[i] && is_ws(str[i]) == 0)
		i++;
	return (i);
}

static int ft_just_export(t_data *data)
{
	t_env *tmp;

    tmp = &data->env;
    while (tmp)
    {
		write(1, "export ", 7);
        write(1, tmp->key, ft_strlen(tmp->key));
        write(1, "=\"", 2);
        write(1, tmp->value, ft_strlen(tmp->value));
        write(1, "\"\n", 2);
        tmp = tmp->next;
    }
	return (0);
}


static int ft_plus_egal_export(char *str, t_data *data)
{
    t_env	*tmp;
	char	*var;
	char	*tmp_for_join;
	int i;
	int k;

	i = -1;
	k = 0;
	while (str[++i] != '=' && str[i] != '+' && str[i])
	{
		if (is_ws(str[i]) == 1 || str[i+1] == '\0')
			return (0);
	}
	if (str[i] == '=')
		return (1);
	tmp = &data->env;
	var = ft_substr(str, 0, i);
	while (tmp->next && ft_strncmp(var, tmp->key, i))
		tmp = tmp->next;
	while (str[k + i + 1] && is_ws(str[k + i + 1]) == 0)
		k++;
	i = i + 2;
	if (ft_strncmp(var, tmp->key, i) == 0)
	{
		tmp_for_join = ft_strjoin(tmp->value, str + i);
		free(tmp->value);
		tmp->value = tmp_for_join;
		free(var);
	}
	else
	{
		tmp->next = ft_lstnew_env();
		tmp = tmp->next;
		tmp->key = var;
		tmp->value = ft_strdup(str + i);
		tmp->printable = 1;
	}
	return (0);
}

static int ft_verif_str_export(char *str)
{
	int i;

	i = 0;
	if (ft_isdigit(str[i]) == 1 || str[i] == '=' || str[i] == '+')
		return (1);
	while (str[++i] != '=' && str[i] != '+')
	{
		if (is_ws(str[i]) == 1 || str[i] == '\0')
			return (0);
		if (ft_isalnum(str[i]) == 0 && str[i] != '_')
			return (1);
	}
	if (str[i] == '+' && str[i + 1] != '=')
		return (1);
	
	return (0);
}


static int ft_ok_export(char *str, t_data *data)
{
    t_env	*tmp;
	char	*var;
	int i;
	int k;

	i = 0;
	k = 0;
	while (str[i] != '=')
	{
		if (is_ws(str[i]))
			return (0);
		i++;
	}	
	tmp = &data->env;
	var = ft_substr(str, 0, i);
	while (tmp->next && ft_strncmp(var, tmp->key, i+1))
		tmp = tmp->next;
	while (str[k + i + 1] && is_ws(str[k + i + 1]) == 0)
		k++;
	i = i + 1;
	if (ft_strncmp(var, tmp->key, i) == 0)
	{

		free(tmp->value);
		free(var);
		tmp->value = ft_strdup(str + i);
	}
	else
	{
		tmp->next = ft_lstnew_env();
		tmp = tmp->next;
		tmp->key = var;
		tmp->value = ft_substr(str, i, ft_strlen_WS(str + i));
		tmp->printable = 1;
	}
	return (0);
}

int ft_export(char **tab, t_data *data)
{
	int		i;
	char	*cmd;
	char	*str;

	i = 0;
	str = ft_tab_to_str(tab, ' ');
	ft_strlen_WS(str);
	if (ft_strncmp(str, "export", 7) == 0)
		return (free(str), ft_just_export(data));
	while (str[i] && str[i] != ' ')
		i++;
	i++;
	while (str[i])
	{
		if (ft_verif_str_export(str + i) == 1)
		{
			cmd = ft_substr(str, i, ft_strlen_WS(str + i));
			ft_printf("export: `%s': not a valid identifier\n", cmd);
			free(cmd);
		}
		else
		{
			if (ft_plus_egal_export(str + i, data) != 0)
				ft_ok_export(str + i, data);
		}
		i = i + ft_strlen_WS(str + i);
		while (str[i] && is_ws(str[i]) == 1)
			i++;
	}
	free(str);
	return (0);
}






	







#include "../_Include/minishell.h"

int	ft_pwd(t_data *data)
{
	(void)data;
	ft_putstr_fd(getcwd(NULL, 0), 1);
	ft_putstr_fd("\n", 1);
	return (0);
}

int ft_exec_builtin(char **cmd, t_data *data)
{
	if (ft_strlen(cmd[0]) == 0)
		return (0);
	if (cmd && ft_strncmp(cmd[0], "env", ft_strlen(cmd[0])) == 0)
		return(ft_env(data), 1);

	if (cmd && ft_strncmp(cmd[0], "export", ft_strlen(cmd[0])) == 0)

		return (ft_export(cmd, data), 1);

	if (cmd && ft_strncmp(cmd[0], "echo", ft_strlen(cmd[0])) == 0)
		return (ft_echo(cmd), 1);

	if (cmd && ft_strncmp(cmd[0], "exit", ft_strlen(cmd[0])) == 0)
		return (ft_exit(cmd, data), 1);

	if (cmd && ft_strncmp(cmd[0], "cd", ft_strlen(cmd[0])) == 0)
		return (ft_cd(cmd, data), 1);

	if (cmd && ft_strncmp(cmd[0], "pwd", ft_strlen(cmd[0])) == 0)
		return (ft_pwd(data), 1);

	if (cmd && ft_strncmp(cmd[0], "unset", ft_strlen(cmd[0])) == 0)
		return (ft_unset(cmd, data), 1);

    return (0);
}

int ft_test_builtin(char **cmd)
{
	if (ft_strlen(cmd[0]) != 0 && cmd && ft_strncmp(cmd[0], "env", ft_strlen(cmd[0])) == 0)
		return (1);
	else if (ft_strlen(cmd[0]) != 0 && cmd && ft_strncmp(cmd[0], "export", ft_strlen(cmd[0])) == 0)
		return (1);
	else if (ft_strlen(cmd[0]) != 0 && cmd && ft_strncmp(cmd[0], "echo", ft_strlen(cmd[0])) == 0)
		return (1);
	else if (ft_strlen(cmd[0]) != 0 && cmd && ft_strncmp(cmd[0], "cd", ft_strlen(cmd[0])) == 0)
		return (1);
	else if (ft_strlen(cmd[0]) != 0 && cmd && ft_strncmp(cmd[0], "pwd", ft_strlen(cmd[0])) == 0)
		return (1);
	else if (ft_strlen(cmd[0]) != 0 && cmd && ft_strncmp(cmd[0], "unset", ft_strlen(cmd[0])) == 0)
		return (1);
	else if (ft_strlen(cmd[0]) != 0 && cmd && ft_strncmp(cmd[0], "exit", ft_strlen(cmd[0])) == 0)
		return (1);
    else
		return (0);
}#include "../_Include/minishell.h"

int	ft_unset(char **str, t_data *data)
{
	int i;
    t_env *before;
    t_env *tmp;
    t_env *after;

	if (ft_strstrlen(str) == 1)
		return (0);
	i = 1;
	while (str[i][0] == '-')
		i++;
	while (str[i] != 0)
	{
		tmp = &data->env;
		before = NULL;
		while (tmp)
		{
			if (ft_strncmp(tmp->key, str[i], ft_strlen(str[i])) == 0)
			{
				after = tmp->next;
				free(tmp->key);
				free(tmp->value);
				if (before == NULL)
					data->env = *after;
				else if (after == NULL)
				{
					free(tmp);
					before->next = NULL;
				}
				else
				{
					free(tmp);
					before->next = after;
				}
				break;
			}
			before = tmp;
			tmp = tmp->next;
		}
		i++;
	}
	return (0);
}
#include "../_Include/minishell.h"

t_env	*ft_lstnew_env(void)
{
	t_env	*new;

	new = malloc(sizeof(t_env));
	if (new == NULL)
		return (NULL);
	new->key = NULL;
	new->value = NULL;
	new->next = NULL;
	return (new);
}

void ft_free_env(t_data *data)
{
	t_env	*tmp;
	t_env	*adresse;

	tmp = &data->env;
	free(tmp->key);
	free(tmp->value);
	tmp = tmp->next;
	while (tmp)
	{
		free(tmp->key);
		free(tmp->value);
		adresse = tmp->next;
		free(tmp);
		tmp = adresse;
	}
}

int ft_create_env(char **envp, t_data *data)
{
	int i;
	int j;
	int k;
	t_env	*tmp;

	i = -1;
	tmp = &data->env;
	while (envp[++i])
	{
		j = 0;
		while (envp[i][j] != '=' && envp[i][j])
			j++;
		k = 0;
		while (envp[i][k + j + 1])
			k++;
		tmp->key = ft_substr(envp[i], 0, j);
		if (!tmp->key)
			return (1);
		tmp->value = ft_substr(envp[i], j + 1, k);
		if (!tmp->key)
			return (1);
		tmp->printable = 1;
		if (envp[i + 1])
		{
			tmp->next = ft_lstnew_env();
			tmp = tmp->next;
		}
		else
			tmp->next = NULL;
	}
	return (0);
}#include "../_Include/minishell.h"

int	ft_exec_cmd_solo(t_data *data, char **cmd)
{
	char **paths_env;
	char *path_exec;
	(void)cmd;

	paths_env = ft_get_paths(data);
	path_exec = find_path(cmd, paths_env);
	ft_dup_manage(data, 0);
	if (ft_test_builtin(cmd) == 1)
	{
		ft_close_all(data->pip);
		ft_exec_builtin(cmd, data);
		ft_init_in_out(data);
		dup2(data->pip.saved_stdin, 0);
		dup2(data->pip.saved_stdout, 1);
		return (1);
	}
	else
		return (0);
}
int	ft_exec_built_in_solo(t_exec *begin, t_data *data)
{
	int tmp_fd;
	char **cmd;
	t_exec *tmp;

	cmd = NULL;
	tmp = begin;
	begin = tmp;
	while (begin && begin->id != F_PIPE)
	{
		if (begin->id == F_CMD)
		{
			cmd = ft_join_dstr(cmd, begin->str);
			if (!cmd)
		}
		begin = begin->next;
	}
	begin = tmp;
	if (!ft_test_builtin(cmd))
		return (ft_free_dchar(cmd), 0);
	while (begin && begin->id != F_PIPE)
	{
		if (begin->id == F_FALSEI)
		{
			tmp_fd = open(begin->str, O_RDWR);
			if (tmp_fd == -1)
			{
				perror(begin->str);
				return(errno);
			}
			ft_close(&tmp_fd);
		}
		else if (begin->id == F_FALSEA)
		{
			tmp_fd = open(begin->str, O_RDWR | O_APPEND | O_CREAT, 0644);
			if (tmp_fd == -1)
			{
				perror(begin->str);
				return(errno);
			}
			ft_close(&tmp_fd);
		}
		else if (begin->id == F_FALSET)
		{
			tmp_fd = open(begin->str, O_CREAT | O_RDWR | O_TRUNC, 0644);
			if (tmp_fd == -1)
			{
				perror(begin->str);
				return(errno);
			}
			ft_close(&tmp_fd);
		}
		else if (begin->id == F_DELIMITER)
		{
			ft_heredoc(data, begin->str, 1 , 0);

		}
		else if (begin->id == F_DELIMITER_SQ)
		{
			ft_heredoc(data, begin->str, 1 , 1);

		}
		else if (begin->id == F_FALSED)
		{
			ft_heredoc(data, begin->str, 0, 0);
		}
		else if (begin->id == F_APPEND)
		{
			data->pip.fd_out = open(begin->str, O_CREAT | O_RDWR | O_APPEND, 0644);
			if (data->pip.fd_out == -1)
			{
				perror(begin->str);
				return(errno);
			}
		}
		else if (begin->id == F_TRONC)
		{
			data->pip.fd_out = open(begin->str, O_CREAT | O_RDWR | O_TRUNC, 0644);
			if (data->pip.fd_out == -1)
			{
				perror(begin->str);
				return(errno);
			}
		}
		else if (begin->id == F_INFILE)
		{
			data->pip.fd_in = open(begin->str, O_RDONLY, 0644);
			if (data->pip.fd_in == -1)
			{
				perror(begin->str);
				return(errno);
			}
		}
		begin = begin->next;
		
	}
	if (ft_exec_cmd_solo(data, cmd) == 1)
	{
		ft_free_dchar(cmd);
		return (1);
	}
	ft_free_dchar(cmd);
	return (0);

#include "../_Include/minishell.h"

extern int err_value;

void	ft_close(int *fd)
{
	if (*fd == -1 || *fd == 1 || *fd == 0)
		return ;
	close(*fd);
	*fd = -1;
}

void	ft_manage_write(char *str, char *delimiter, t_data *data, int sq)
{
	int	i;

	i = 0;
	(void)sq;
	(void)delimiter;

	write(data->pip.tmp_fd, str, ft_strlen(str));
	write (data->pip.tmp_fd, "\n", 1);
}
char	*ft_heredoc(t_data *data, char *delimiter, int w, int sq)
{
	char	*str;
	char	*name;

	if (w)
	{
		name = ft_randomstr("/tmp/hd_", NULL, 16);
		data->pip.tmp_fd = open(name, O_TRUNC | O_CREAT | O_RDWR, 00777);
		if (data->pip.tmp_fd == -1)
	}
	str = readline(">");
	if (err_value == 130)
	{
		data->last_err_num = 130;
		return (NULL);
	}
	if (!sq)
		str = ft_convert_variable_hd(str, data, delimiter);
	if (w && str && ft_strncmp(delimiter, str, ft_strlen(delimiter) + 1))
		ft_manage_write(str, delimiter, data, sq);
	while (str && (ft_strncmp(delimiter, str, ft_strlen(delimiter) + 1)))
	{
		free(str);

		rl_event_hook=event;
		str = readline(">");
		if (err_value == 130)
			break;
		if (!sq)
			str = ft_convert_variable_hd(str, data, delimiter);
		if (w && str && ft_strncmp(delimiter, str, ft_strlen(delimiter) + 1))
			ft_manage_write(str, delimiter, data, sq);
	}
	if (err_value == 130)
	{
		data->last_err_num = 130;
		return (NULL);
	}
	free(str);
	if(w)
	{
		ft_close(&data->pip.tmp_fd);
	}
	return (name); 
}

void	ft_init_pipex_pipe(t_data *data)
{
	data->pip.pipefd1[0] = -1;
	data->pip.pipefd1[1] = -1;
	data->pip.pipefd2[0] = -1;
	data->pip.pipefd2[1] = -1;
}
#include "./minishell.h"

int id2;

char **ft_join_dstr(char **dest, char* src)
{
	int	i;
	char **tmp;

	i = 0;
	tmp = malloc(sizeof(char *) * (ft_strstrlen(dest) + 2));
		return (NULL);
	while (dest && dest[i])
	{
		tmp[i] = ft_strdup(dest[i]);
		if (!tmp[i])
		i++;
	}
	tmp[i] = ft_strdup(src);
	if (!tmp[i])
		return (NULL); 
	i++;
	tmp[i] = 0;
	dest = tmp;
	return (dest);
}

char **ft_get_paths(t_data *data)
{
    t_env *tmp;

    tmp = &data->env;
    while (tmp)
    {
        if (ft_strncmp(tmp->key, "PATH", ft_strlen(tmp->key)) == 0)
        {
            return (ft_split(tmp->value, ':'));
        }
        tmp = tmp->next;
    }
	return (NULL);
}

char	*find_path(char **cmd, char **paths_env)
{
	char *tmp;
	int	i;

	i = 0;
	if (cmd && cmd[0] && !cmd[0][0])
		return (ft_putstr_fd(": Command not found\n", 2), exit(127), NULL);
	if (ft_test_builtin(cmd) == 1)
		return (NULL);
	fprintf(stderr, "cmd[0] %d\n", access(cmd[0], X_OK));
	if (!access(cmd[0], R_OK) && (cmd[0][0] != '.' || cmd[0][0] != '/'))
	{
		if (access(cmd[0], X_OK))
			return (perror(cmd[0]), exit(errno), NULL);
		else if (cmd[0][0] != '.' && cmd[0][0] != '/')
		{
			ft_putstr_fd(cmd[0], 2);
			if (ft_strchr(cmd[0], '/'))
				ft_putstr_fd(": No such file or directory\n", 2);
			else
				ft_putstr_fd(": Command not found\n", 2);
			return (exit(127), NULL);

		}
		else
			return (ft_strdup(cmd[0]));
	}
	while (paths_env && paths_env[i])
	{
		tmp = ft_strrjoin(paths_env[i], "/", cmd[0]);
		if(!tmp)
			return (ft_putstr_fd(MALLOC_ERROR, 2), NULL);
		if (!access(tmp, F_OK))
		{
			if (access(tmp, X_OK))
				return (perror(cmd[i]), free(tmp), exit(errno), NULL);
			else
				return (tmp);
		}
		i++;
		free(tmp);
	}
		fprintf(stderr, "ICIIIII\n");
	ft_putstr_fd(cmd[0], 2);
	if (ft_strchr(cmd[0], '/'))
		ft_putstr_fd(": No such file or directory\n", 2);
	else
		ft_putstr_fd(": Command not found\n", 2);
	return (exit(127), NULL);
}
int	is_out(char *str)
{
	int	i;
	char **tmp;

	i = 0;
	if (!str || !str[0])
		return (0);
	tmp = ft_split(str, '/');
	if (!tmp)
		return (-1);
	if (ft_strncmp(tmp[0], "dev", ft_strlen(tmp[0])) == 0 && ft_strncmp(tmp[1], "stdout", ft_strlen(tmp[1])) == 0)
		return (ft_free_dchar(tmp),1);
	ft_free_dchar(tmp);
	return (0);
}
{
	int count;
	t_exec *tmp;

	tmp = begin;
	begin = tmp;
	count = 0;
	while (begin && count < m)
	{
		if (begin->id == F_PIPE)
			count++;
		begin = begin->next;
	}
	while (begin && begin->id != F_PIPE)
	{
		if (begin->id == token && !is_out(begin->str))
			return (1);
		begin = begin->next;
	}
	begin = tmp;
	return (0);
}

void ft_print_fd(t_data *data)
{
	fprintf(stderr, "fd in %d\n", data->pip.fd_in);
	fprintf(stderr, "fd out %d\n", data->pip.fd_out);
	fprintf(stderr, "pipefd1 [0] %d\n", data->pip.pipefd1[0]);
	fprintf(stderr, "pipefd1 [1] %d\n", data->pip.pipefd1[1]);
	fprintf(stderr, "pipefd2 [0]  %d\n", data->pip.pipefd2[0]);
	fprintf(stderr, "pipefd2 [1] %d\n", data->pip.pipefd2[1]);
}

int ft_search_hd_name(t_exec *begin, int m)
{
	t_exec *tmp;
	int		fd;

	tmp = begin;
	while (m)
	{
		if (tmp->id == F_PIPE)
			m--;
		tmp = tmp->next;
	}
	while (tmp && tmp->id != F_PIPE)
	{
		if (tmp->id == F_DELIMITER || tmp->id == F_DELIMITER_SQ)
		{
			fd = open(tmp->hd_filename, O_RDONLY);
			if (fd == -1)
			return (fd);
		}
		tmp = tmp->next;
	}
	return (-2);
}

void ft_dup_manage(t_data *data, int m)
{
	int tmp_fd;

	if (contain_token(&data->exec, F_INFILE, m))
	{
		dup2(data->pip.fd_in, 0);
	}
	else if (contain_token(&data->exec, F_DELIMITER, m) || contain_token(&data->exec, F_DELIMITER_SQ, m))
	{
		tmp_fd = ft_search_hd_name(&data->exec, m);
		dup2(tmp_fd, 0);
		ft_close(&tmp_fd);
	}
	else if (m % 2 == 0)
	{
		ft_close(&data->pip.pipefd2[1]);
		dup2(data->pip.pipefd2[0], 0);
		ft_close(&data->pip.pipefd2[0]);

	}
	else
	{
		ft_close(&data->pip.pipefd1[1]);
		dup2(data->pip.pipefd1[0], 0);
		ft_close(&data->pip.pipefd1[0]);
	}
	if (contain_token(&data->exec, F_APPEND, m) || contain_token(&data->exec, F_TRONC, m) || m == data->pip.nb_pipes)
	{
		dup2(data->pip.fd_out, 1);
	}
	else if (m % 2 == 0)
	{
		ft_close(&data->pip.pipefd1[0]);
		dup2(data->pip.pipefd1[1], 1);
		ft_close(&data->pip.pipefd1[1]);
	}
	else if (m % 2 == 1)
	{
		ft_close(&data->pip.pipefd2[0]);
		dup2(data->pip.pipefd2[1], 1);
		ft_close(&data->pip.pipefd2[1]);
	}
}

int	ft_len_list(t_env *begin)
{
	t_env *tmp;
	int	count;

	tmp = begin;
	count = 0;
	while (begin)
	{
		count++;
		begin = begin->next;
	}
	begin = tmp;
	return (count);
}


char **ft_get_env(t_env *env)
{
	t_env *tmp;
	char **output;
	int	k;
	int count = 0;
	tmp = env;
	k = 0;
	output = malloc(sizeof(char *) * (ft_len_list(env) + 1));
	if (!output)
		return (NULL);
	output[ft_len_list(env)] = 0;
	while (env)
	{
		output[k] = malloc(sizeof(char) * (ft_strlen(env->key) + ft_strlen(env->value) + 2));
		if (!output[k])
			return (ft_free_dchar(output), NULL);
		ft_memcpy(output[k], env->key, ft_strlen(env->key));
		output[k][ft_strlen(env->key)] = '=';
		ft_memcpy(output[k] + ft_strlen(env->key) + 1, env->value, ft_strlen(env->value)  + 1);
		k++;
		env = env->next;
		count++;
	}
	env  = tmp;
	return (output);
}

void	ft_exec_cmd(t_data *data, char **cmd, int m)
{
	char **paths_env;
	char *path_exec;
	char **env_tab;
	(void)cmd;

	env_tab = ft_get_env(&data->env);
	paths_env = ft_get_paths(data);
	path_exec = find_path(cmd, paths_env);
	ft_dup_manage(data, m);
	if (ft_exec_builtin(cmd, data) == 1)
	{
		ft_close_all(data->pip);
		if (data->pip.nb_pipes)
			exit(data->err_built_in);
		else
			return ;
	}
	
	execve(path_exec, cmd, env_tab);
	if (errno == 13)
	{
		ft_putstr_fd(cmd[0],2);
		ft_putstr_fd(": Is a direeeectory\n", 2);
		exit(126);
	}
	perror("EXEC");
	exit(errno);
}

void	ft_reset_param_pip(t_data *data)
{
	data->pip.fd_in = 0;
	data->pip.fd_out = 1;
	data->pip.hd_in = 0;
}


int	ft_child_exec(t_exec *begin, t_data *data, int m)
{
	int tmp_fd;
	char **cmd;

	cmd = NULL;
	while (begin && begin->id != F_PIPE)
	{
		if (begin->id == F_FALSEI)
		{
			tmp_fd = open(begin->str, O_RDWR);
			if (tmp_fd == -1)
			{
				perror(begin->str);
				exit(errno);
			}
			ft_close(&tmp_fd);
		}
		else if (begin->id == F_FALSEA)
		{
			tmp_fd = open(begin->str, O_RDWR | O_APPEND | O_CREAT, 0644);
			if (tmp_fd == -1)
			{
				perror(begin->str);
				exit(errno);
			}
			ft_close(&tmp_fd);
		}
		else if (begin->id == F_FALSET)
		{
			tmp_fd = open(begin->str, O_CREAT | O_RDWR | O_TRUNC, 0644);
			if (tmp_fd == -1)
			{
				perror(begin->str);
				exit(errno);
			}
			ft_close(&tmp_fd);
		}
		else if (begin->id == F_FALSED)
			ft_heredoc(data, begin->str, 0, 0);
		else if (begin->id == F_CMD)
		{
			cmd = ft_join_dstr(cmd, begin->str);
			if (!cmd)
		}
		else if (begin->id == F_APPEND)
		{
			data->pip.fd_out = open(begin->str, O_CREAT | O_RDWR | O_APPEND, 0644);
			if (data->pip.fd_out == -1)
			{
				perror(begin->str);
				exit(errno);
			}
		}
		else if (begin->id == F_TRONC)
		{
			data->pip.fd_out = open(begin->str, O_CREAT | O_RDWR | O_TRUNC, 0644);
			if (data->pip.fd_out == -1)
			{
				perror(begin->str);
				exit(errno);
			}
		}
			else if (begin->id == F_INFILE)
		{
			data->pip.fd_in = open(begin->str, O_RDONLY, 0644);
			if (data->pip.fd_in == -1)
			{
				perror(begin->str);
				exit(errno);
			}
		}
		begin = begin->next;
		
	}
	ft_exec_cmd(data, cmd, m);
	ft_free_dchar(cmd);
	return (0);
}

void	ft_init_in_out(t_data *data)
{
	data->pip.fd_in = dup(data->pip.saved_stdin);
	data->pip.fd_out = dup(data->pip.saved_stdin);
}
void	ft_pipex(t_data *data)
{
	t_exec	*begin;
	int		m;


	begin = &data->exec;
	m = 0;
	if (!data->pip.nb_pipes)
		if(ft_exec_built_in_solo(begin, data))
			return ;
	begin = &data->exec;
	while (begin)
	{
		ft_init_in_out(data);
		if (!m || m % 2 == 0)
			pipe(data->pip.pipefd1);
		else
			pipe(data->pip.pipefd2);
		ft_init_sigint_exec();
		ft_init_sigquit_exec();

		data->pip.last_id = fork();
		if (data->pip.last_id == 0)
			ft_child_exec(begin, data, m);
		if (!m || m % 2 == 0)
		{
			ft_close(&data->pip.pipefd2[0]);
			ft_close(&data->pip.pipefd1[1]);
		}
		else
		{
			ft_close(&data->pip.pipefd1[0]);
			ft_close(&data->pip.pipefd2[1]);
		}
		while (begin && begin->id != F_PIPE)
			begin = begin->next;
		if (begin && begin->id == F_PIPE)
			begin = begin->next;
		
		m++;
	}
		waitpid(data->pip.last_id, &data->last_err_num, 0);
		if (WIFEXITED(data->last_err_num))
			data->last_err_num = WEXITSTATUS(data->last_err_num);
		while (wait(NULL) != -1)
			(void)begin;
		ft_close_all(data->pip);
}



#include "../_Include/minishell.h"

int	ft_in_q(int in_q)
{
	if (in_q == 0)
		return (1);
	else
		return (0);
}#include "./minishell.h"



void	ft_unlink_hd(t_exec *begin)
{
	t_exec *tmp;

	tmp = begin;
	while (tmp)
	{
		if (begin->hd_filename != NULL)
		{
			unlink(begin->hd_filename);
		}
		tmp = tmp->next;
	}
	
}
#ifndef MINISHELL_H

# define MINISHELL_H

# include "../../libft/src/inc/SuperLibft.h"

# include <stdio.h>
# include <unistd.h>
# include <stdio.h>
# include <readline/readline.h>
# include <readline/history.h>
# include <unistd.h>
# include <signal.h>
# include <sys/types.h>
# include <dirent.h>
# include <errno.h>
#include <sys/types.h>
#include <sys/wait.h>

#define WS " \t\n\f\v\r"
#define MALLOC_ERROR "erreur de malloc"
#define MAL_ERCODE 42


#define F_INFILE 0
#define F_DELIMITER 1
#define F_DELIMITER_SQ 4

#define F_FALSEI 2
#define F_FALSED 3

#define F_PIPE 5

#define F_CMD 10

#define F_APPEND 6
#define F_TRONC 7
#define F_FALSEA 8
#define F_FALSET 9

void    ft_logo(void);

typedef	struct	s_env
{
	int				printable;
    char			*key;
	char			*value;
	struct s_env	*next;
	
}               t_env;

typedef struct	s_exec
{
	char			*str;
	int				id;
	char			*hd_filename;
	int				touch;
	struct s_exec	*next;
	struct s_exec	*prev;

}				t_exec;

typedef	struct	s_pip
{
	int		fd_in;
	int		last_id;
	int		hd_in;
	int		fd_out;
	int		nb_pipes;
	int		tmp_fd;
	int		saved_stdin;
	int		saved_stdout;
	int		pipefd1[2];
	int		pipefd2[2];
}				t_pip;


typedef	struct	s_data
{
	t_env	env;
	t_exec	exec;
	t_pip	pip;
    char 	**args;
	int		ac;
	char 	**av;
	char	**envp;
	char	*sep;
	int		hd;
	char	*pwd;
	char	*oldpwd;
	int		err_built_in;
	int		last_err_num;
	char	*last_err_str;
	
}               t_data;


void	ft_parse_for_exec(t_data *data);
char	*ft_parse(char *str, t_data *data);
int		is_ws(char c);
char	*ft_check_env(char *str, t_data *data);
size_t	ft_strlen_WS_quotes(const char *str);
char *ft_convert_variable(char *str, t_data *data);
char *ft_convert_variable_hd(char *str, t_data *data, char *delimiter);






int ft_init(char **env, t_data *data);

int		ft_create_env(char **envp, t_data *data);
t_env	*ft_lstnew_env(void);
void	ft_free_env(t_data *data);
int		ft_env(t_data *data);


int		ft_unset(char **strr, t_data *data);

int		ft_export(char **str, t_data *data);

int		ft_echo(char **cmd);

int		ft_pwd(t_data *data);

int		ft_cd(char **str, t_data *data);

int	ft_exit(char **str, t_data *data);

int		ft_test_builtin(char **str);
int		ft_exec_builtin(char **cmd, t_data *data);

void	ft_print_list(t_exec *begin);


void	ft_ctrlb(int a);
void	ft_ctrlb_exec(int a);
void	ft_ctrlc_exec(int a);
void	ft_ctrlc_hd(int a);

int event(void);

void	ft_ctrlc(int a);

void	ft_print_dchar(char **strstr);


char	**ft_split_k(char const *s, char *sep);
char	**ft_split_l(char const *s, char *sep);


void	ft_print_dargs(char **strstr);
void	ft_unlink_hd(t_exec *begin);

int	ft_in_q(int in_q);

void	ft_pipex(t_data *data);
void ft_dup_manage(t_data *data, int m);
int	contain_token(t_exec* begin, int token, int m);
char	*find_path(char **cmd, char **paths_env);
char **ft_get_paths(t_data *data);
char **ft_join_dstr(char **dest, char* src);
void	ft_init_in_out(t_data *data);


int		ft_strstrlen(char **strstr);
size_t	ft_strlen_WS(const char *str);
char *ft_put_str_in_str(char *dest, char *src, int ind);

char	*ft_heredoc(t_data *data, char *delimiter, int w, int sq);
void	ft_close(int *fd);
void	ft_init_pipex_pipe(t_data *data);


void	ft_free_dchar(char **str);
char    *ft_strrjoin(char const *s1, char const *s2, char const *s3);
void    ft_close_all(t_pip pip);
char *ft_tab_to_str(char **tab, char sep);

char	**ft_split_lq(char const *s, char *sep);

int	ft_exec_built_in_solo(t_exec *begin, t_data *data);


void	ft_init_sigint_exec(void);
void	ft_init_sigquit_exec(void);
void	ft_init_sigquit(void);
void	ft_init_sigint(void);
void	ft_init_sigint_hd(void);


#endif









#include "../_Include/minishell.h"

extern t_data data;


	
void	ft_print_list(t_exec *begin)
{
	while (begin)
	{
		fprintf(stderr, "(%d) \t %s\n", begin->id, begin->str);
		begin = begin->next;
	}
	
}

int	is_ws(char c)
{
	int	i;
	const char ws[] = " \n\t\f\r\v";

	i = 0;
	while (ws[i])
	{
		if (c == ws[i])
			return (1);
		i++;
	}
	return (0);
	
}

char	*ft_clean(char *str)
{
	int	i;
	int	in_dq;
	int	in_sq;
	char *tmp;

	i = 0;
	in_dq = 0;
	in_sq = 0;
	while (str && str[i])
	{
		if (str[i] == '"' && !in_sq)
		{
			in_dq = ft_in_q(in_dq);
		}
		else if (str[i] == '\'' && !in_dq)
		{
			in_sq = ft_in_q(in_sq);
		}
		if (!in_dq && !in_sq && is_ws(str[i]) && is_ws(str[i + 1]))
			ft_memmove(str + i, (str + i + 1), ft_strlen(str + i) + 2);
		else if ((str[i] == '<' && str[i+1] != '<' && str[i+1] != ' ' && str[i+1]) || (str[i] == '>' && str[i+1] != '>' && str[i+1] != ' ' && str[i+1]))
		{
			tmp = ft_put_str_in_str(str, " ", ++i);
			free(str);
			str = tmp;
		}
		else if ((str[i] && str[i] != '<' && str[i] != ' ' && str[i + 1] && str[i + 1] == '<') || (str[i] && str[i] != '>' && str[i] != ' ' && str[i + 1] && str[i + 1] == '>'))
		{
			tmp = ft_put_str_in_str(str, " ", ++i);
			free(str);
			str = tmp;
			i++;
		}
		else
			i++;
	}
	if (in_dq || in_sq)
		return (free(str), write(2, "Quotes error\n", 14), NULL);
	return (str);
}

void	ft_clean_ws(t_data *data)
{
	int	i;
	int k;

	i = 0;
	while (data->args && data->args[i])
	{
		
		if (is_ws(data->args[i][0]))
			ft_memmove(data->args[i], data->args[i] + 1, ft_strlen(data->args[i]));
		k = ft_strlen(data->args[i]);
		if (is_ws(data->args[i][k - 1]))
			data->args[i][k - 1] = '\0';
		i++;
	}
	
}

static void	ft_maj_quotes(int *dq, int *sq, char c)
{
	if (c == '"' && *sq == -1)
		*dq *= -1;
	if (c == '\'' && *dq == -1)
		*sq *= -1;
}

size_t	ft_strlen_var_env(char *str)
{
	int	i;

	i = 1;
	if (str && ft_isdigit(str[1]))
		return (2);
	while (str && str[i])
	{
		if (!ft_isalnum(str[i]) && str[i] != '_')
			return (i);
		i++;
	}
	return (i);
}
size_t	ft_strlen_WS_quotes(const char *str)
{
	size_t	i;

	i = 0;
	while (str[i] && (is_ws(str[i]) == 0 && str[i] != '"' && str[i] != '\''))
		i++;
	return (i);
}

char	*ft_check_env(char *str, t_data *data)
{
	t_env *tmp_env;
	tmp_env = &data->env;
	if (str && str[0]=='?')
		return (ft_itoa(data->last_err_num));
	while (tmp_env)
	{
		if (!strncmp(str, tmp_env->key, ft_strlen_var_env(str)))
			return (tmp_env->value);
		tmp_env = tmp_env->next;
	}
	return (NULL);
	
}

int	ft_is_hd(char *str, int	i)
{
	int	j;

	j = 0;
	if (i > 0)
		i--;
	else
		return (0);
	fprintf(stderr, "STR1 = %s i %d\n", str, i);
	while (str && i >= 0 && (is_ws(str[i]) || str[i] == '"' || str[i] == '\''))
		i--; 
	fprintf(stderr, "STR2 = %s i %d\n", str, i);
	if (i > 0 && str[i] == '<'  && str[i - 1] == '<')
		return (1);
	return (0);
}
char *ft_convert_variable(char *str, t_data *data)
{
	int	i;
	int dq;
	int sq;
	char *var;
	
	sq = -1;
	dq = -1;
	i = 0;
	while (str && str[i])
	{
		if (str[i] == '\'' || str[i] == '"')
			ft_maj_quotes(&dq, &sq, str[i]);
		if (str[i] == '$' && str[i + 1] && !is_ws(str[i + 1]) && sq == -1)
		{
			var = ft_check_env(str + i + 1, data);
			if (!ft_is_hd(str, i))
			{
				fprintf(stderr, "ON RENTRE\n");
				ft_memmove(str + i, str + i + ft_strlen_var_env(str + i), ft_strlen(str + i + ft_strlen_var_env(str + i))+ 1);
				str = ft_put_str_in_str(str, var, i);
				i = 0;
			}

		}
		i++;
	}
	return (str);
	
}

char *ft_convert_variable_hd(char *str, t_data *data, char *delimiter)
{
	int	i;
	int dq;
	int sq;
	char *var;
	
	sq = -1;
	dq = -1;
	i = 0;
	while (str && str[i])
	{
		if (str[i] == '\'' || str[i] == '"')
			ft_maj_quotes(&dq, &sq, str[i]);
		if (str[i] == '$' && str[i + 1] && !is_ws(str[i + 1]) && sq == -1)
		{
			var = ft_check_env(str + i + 1, data);
			if (ft_strncmp(delimiter, str, ft_strlen(str)))
			{
				ft_memmove(str + i, str + i + ft_strlen_var_env(str + i), ft_strlen(str + i + ft_strlen_var_env(str + i))+ 1);
				str = ft_put_str_in_str(str, var, i);
				i = 0;
			}
		}
		if (str && str[i])
			i++;
	}
	return (str);
}


int ft_verif_just_chev(char *str)
{
	int i;
	int j;
	int dq;
	int sq;

	i = 0;
	dq = -1;
	sq = -1;
	while (str && str[i])
	{
		ft_maj_quotes(&dq, &sq, str[i]);
		if (str[i] == '<' && str[i+1] != '<' && dq != 1 && sq != 1)
		{
			j = i + 1;
			while (1)
			{
				if (is_ws(str[j]))
					j++;
				else if (str[j] == '<' || str[j] == '>' || str[j] == '|')
					return (ft_putstr_fd("syntax error near unexpected token `", 2), ft_putchar_fd(str[j], 2), ft_putstr_fd("'\n", 2), 0);
				else if (str[j] == '\0')
					return (ft_putstr_fd("syntax error near unexpected token `newline'\n", 2), 0);
				else
					break ;
			}
		}
		i++;
	}
	return (1);
}

{
	char *tmp;

	tmp = str;
	str = ft_convert_variable(str, data);
	str = ft_strtrim(str, WS);
	if (!str || str[0] == '\0')
		return (free(str), NULL);
	str = ft_clean(str);
	if (!str)
		return (NULL);
	if (ft_verif_just_chev(str) == 0)
		return (NULL);
	data->args = ft_split_k(str, "|");
	ft_clean_ws(data);
	 return (str);
}


t_exec	*ft_lstnew_pars(void)
{
	t_exec	*new;

	new = malloc(sizeof(t_exec));
	if (new == NULL)
		return (NULL);
	new->str = NULL;
	new->id = -42;
	new->next = NULL;
	new->prev = NULL;
	new->hd_filename = NULL;
	return (new);
}

void ft_clean_list_exec(t_data *data)
{
	t_exec *tmp;
	t_exec *before;


	tmp = &data->exec;
	tmp->prev = NULL;
	while (tmp->next != NULL)
	{
		before = tmp;
		tmp = tmp->next;
		if (tmp != NULL)
			tmp->prev = before;
	}
	tmp = tmp->prev;
	tmp->next = NULL;
}

char ft_first_no_chev(char *str)
{
	int	i;

	i = 0;
	while (str && str[i])
	{
		if (str[i] != '<' && !is_ws(str[i]))
			return (str[i]);
		i++;
	}
	return (0);
}
int	ft_find_if_hd_quotes(t_data *data, int count_p)
{
	t_exec *tmp;
	int len1;
	int len2;

	tmp = &data->exec;
	(void)count_p;
	len1 = ft_strlen(data->args[count_p]);
	len2 = len1;
	while (len1 - 1)
	{
		if (len1 - 2 >= 0 && data->args[count_p][len1 - 1] == '<' && data->args[count_p][len1 - 2] == '<')
		{
			if (len1 != len2 && (ft_first_no_chev(data->args[count_p] + len1) == '\'' || ft_first_no_chev(data->args[count_p] + len1) == '"'))
				return (1);
		}
		len1--;

	}
	return (0);
}


void ft_modif_in_out(t_data *data)
{
	t_exec	*tmp;
	int		bool_out;
	int		bool_in;
	int count_p;
	t_exec	*tmpstart;

	count_p = 0;
	tmp = &data->exec;

	while (tmp != NULL)
	{
		tmpstart = tmp;
		bool_in = 0;
		bool_out = 0;
		while (tmp->next != NULL && tmp->id != F_PIPE)
			tmp = tmp->next;
		if (tmp->id == F_PIPE)
			tmp = tmp->prev;
		while (tmp != NULL && tmp->id != F_PIPE)
		{
			if (tmp->id == F_APPEND)
			{
				if (bool_out == 1)
					tmp->id = F_FALSEA;
				else
					bool_out = 1;
			}
			if (tmp->id == F_TRONC)
			{
				if (bool_out == 1)
					tmp->id = F_FALSET;
				else
					bool_out = 1;
			}
			if (tmp->id == F_INFILE)
			{
				if (bool_in == 1)
					tmp->id = F_FALSEI;
				else
					bool_in = 1;
			}
			if (tmp->id == F_DELIMITER || tmp->id == F_DELIMITER_SQ)
			{
				if (bool_in == 1)
				{
					ft_init_sigint_hd();
					ft_heredoc(data, tmp->str, 0, 0);
					ft_init_sigint();
					tmp->id = F_FALSED;
				}
				else if (tmp->id == F_DELIMITER)
				{
					ft_init_sigint_hd();
					tmp->hd_filename = ft_heredoc(data, tmp->str, 1, 0);
					ft_init_sigint();
					bool_in = 1;
				}
				else 
				{
					ft_init_sigint_hd();
					tmp->hd_filename = ft_heredoc(data, tmp->str, 1, 1);
					ft_init_sigint();
					bool_in = 1;
				}
			}
			tmp = tmp->prev;
		}
		tmp = tmpstart;
		if (tmp->id == F_PIPE && tmp->next != NULL)
			tmp = tmp->next;
		while (tmp->next != NULL && tmp->id != F_PIPE)
			tmp = tmp->next;
		if (tmp != NULL)
		{
			tmp = tmp->next;
		}
		

	}
}
int	ft_count_pipes (t_exec *begin)
{
	int count;
	t_exec *tmp;

	tmp = begin;
	count = 0;
	while (begin)
	{
		if (begin->id == F_PIPE)
			count++;
		begin = begin->next;
	}
	return (count);
	
}
int ft_check_chev_pip(char **tab)
{
	int	i;

	i = 0;
	while(tab && tab[i])
	{
		if (ft_strlen(tab[i]) != 0 && !ft_strncmp(tab[i], "<", ft_strlen(tab[i])))
			if (tab[i + 1] && ft_strlen(tab[i + 1]) != 0 && !ft_strncmp(tab[i + 1], "<", ft_strlen(tab[i + 1])))
				return (fprintf(stderr, "ERROR PRES DE GNEUGNEU\n"), 1);
		i++;
	}
	return (0);
	
}
void ft_parse_for_exec(t_data *data)
{
	int i;
	int j;
	int count_p;
	t_exec *tmp;
	char **tab;


	tmp = &data->exec;
	j = -1;
	count_p = 0;
	while (data->args[++j])
	{
		tab = ft_split_lq(data->args[j], " ");
		if (ft_check_chev_pip(tab) == 1)
			return ;
		i = 0;
		while (tab && tab[i])
		{
			
			tab[i] = ft_strtrim(tab[i], "\"'");
			if (ft_strlen(tab[i]) != 0 && !ft_strncmp(tab[i], "<", ft_strlen(tab[i])))
				i++;
			else if (ft_strlen(tab[i]) != 0 && !ft_strncmp(tab[i], "<<", ft_strlen(tab[i])))
				i++;
			else if (ft_strlen(tab[i]) != 0 && !ft_strncmp(tab[i], ">", ft_strlen(tab[i])))
				i++;
			else if (ft_strlen(tab[i]) != 0 && !ft_strncmp(tab[i], ">>", ft_strlen(tab[i])))
				i++;
			else if (ft_strlen(tab[i]) != 0 && !ft_strncmp(tab[i], "|", ft_strlen(tab[i])))
			{
				count_p++;
				tmp->id = F_PIPE;
				tmp->str = ft_strdup(tab[i]);
				tmp->next = ft_lstnew_pars();
				tmp = tmp->next;
				i++;
			}
			else
			{
				if (0 < i && tab[i-1] && ft_strlen(tab[i - 1]) != 0 && !ft_strncmp(tab[i - 1], "<", ft_strlen(tab[i - 1])))
				{
					tmp->id = F_INFILE;
					tmp->str = ft_strdup(tab[i]);
					tmp->next = ft_lstnew_pars();
					tmp = tmp->next;
					i++;	
				}
				else if (0 < i && tab[i-1] && ft_strlen(tab[i - 1]) != 0 && !ft_strncmp(tab[i - 1], "<<", ft_strlen(tab[i - 1])))
				{
					if (ft_find_if_hd_quotes(data, count_p))
						tmp->id = F_DELIMITER_SQ;
					else
						tmp->id = F_DELIMITER;
					fprintf(stderr, "tmp->id = %d\n",  tmp->id);
					fprintf(stderr, "count_p= %d\n",  count_p);
					tmp->str = ft_strdup(tab[i]);
					tmp->next = ft_lstnew_pars();
					tmp = tmp->next;
					i++;	
				}
				else if (0 < i && tab[i-1] && ft_strlen(tab[i - 1]) != 0 && !ft_strncmp(tab[i - 1], ">", ft_strlen(tab[i - 1])))
				{
					tmp->id = F_TRONC;
					tmp->str = ft_strdup(tab[i]);
					tmp->next = ft_lstnew_pars();
					tmp = tmp->next;
					i++;	
				}
				else if (0 < i && tab[i-1] && ft_strlen(tab[i - 1]) != 0 && !ft_strncmp(tab[i - 1], ">>", ft_strlen(tab[i - 1])))
				{
					tmp->id = F_APPEND;
					tmp->str = ft_strdup(tab[i]);
					tmp->next = ft_lstnew_pars();
					tmp = tmp->next;
					i++;	
				}
				else
				{
					tmp->id = F_CMD;
					tmp->str = ft_strdup(tab[i]);
					tmp->next = ft_lstnew_pars();
					tmp = tmp->next;
					i++;	
				}
			}
		}
	}
	ft_clean_list_exec(data);
	ft_modif_in_out(data);
	data->pip.nb_pipes = ft_count_pipes(&data->exec);
}




extern int err_value;

void	ft_ctrlc(int a)
{
	(void)a;
	write(1, "\n", 1);
	rl_on_new_line();
	rl_replace_line("", 0);
	rl_redisplay();
	return ;
}
void	ft_ctrlc_exec(int a)
{
	(void)a;
	write(1, "\n", 2);
	return ;
}

void	ft_ctrlc_hd(int a)
{
	(void)a;
	err_value = 130;
	rl_done = 1;
	return ;
}

void	ft_ctrlb_exec(int a)
{
	(void)a;
	ft_putstr_fd("Quit (core dumped)\n", 2);
	return ;
}

void	ft_ctrlb(int a)
{
	(void)a;
}

#include "../_Include/minishell.h"

extern t_data data;

int event(void)
{ 
	return (42);
}

int ft_init(char **env, t_data *data)
{
	data->sep = "|";
	data->envp = env;
	data->hd = 0;
	data->pwd = getcwd(NULL, 0);
	data->oldpwd = getcwd(NULL, 0);
	data->pip.fd_in = 0;
	data->pip.last_id = -1;
	data->last_err_num = 0;
	data->err_built_in = 1;
	data->pip.saved_stdin = dup(0);
	data->pip.saved_stdout = dup(1);
	data->pip.fd_out = 1;
	data->pip.hd_in = 0;
	ft_init_pipex_pipe(data);
	ft_create_env(env, data);
	rl_event_hook=event;
	return (0);
}#include "../_Include/minishell.h"

extern t_data data;

void    ft_logo(void)
{
    const char *logo;
	
	logo = "\t\t\t\t\t\t\t\t\t\t      |\
	\n|   /██      /██ /██████ /██   /██ /██████  /██████  /██   /██ /████████ /██       /██ \t      |\
	\n|  | ███    /███|_  ██_/| ███ | ██|_  ██_/ /██__  ██| ██  | ██| ██_____/| ██      | ██ \t      |\
	\n|  | ████  /████  | ██  | ████| ██  | ██  | ██  \\__/| ██  | ██| ██      | ██      | ██ \t      |\
	\n|  | ██ ██/██ ██  | ██  | ██ ██ ██  | ██  |  ██████ | ████████| █████   | ██      | ██ \t      |\
	\n|  | ██  ███| ██  | ██  | ██  ████  | ██   \\____  ██| ██__  ██| ██__/   | ██      | ██ \t      |\
	\n|  | ██\\  █ | ██  | ██  | ██\\  ███  | ██   /██  \\ ██| ██  | ██| ██      | ██      | ██ \t      |\
	\n|  | ██ \\/  | ██ /██████| ██ \\  ██ /██████|  ██████/| ██  | ██| ████████| ████████| ████████  |\
	\n|  |__/     |__/|______/|__/  \\__/|______/ \\______/ |__/  |__/|________/|________/|________/  | ";
	printf("\e[32;1m ---------------------------------------------------------------------------------------------\n|\
	%s\n|\t\t\t\t\t\t\t\t\t\t\t      |\n ---------------------------------------------------------------------------------------------\n\n\e[0m", logo);
    
}#include "../_Include/minishell.h"

int		err_value;

void	ft_print_dargs(char **strstr)
{
	int	i;

	i = 0;
	while (strstr && strstr[i])
	{
		printf("|%s| \n", strstr[i]);
		i++;
	}
	
}
void	ft_print_dchar(char **strstr)
{
	int	i;

	i = 0;
	while (strstr && strstr[i])
	{
		fprintf(stderr, "tab[%d] = |%s|\n", i, strstr[i]);
		i++;
	}
	if (!strstr)
		fprintf(stderr, "STRSTR N EXISTE PAS\n");
}


char *ft_prompt(void)
{
	char *path;
	char *minipath;
	int i;

	i = 0;
	path = getcwd(NULL, 0);
	if (!path)
	while (path && path[i])
		i++;
	i--;
	while (path && path[i] != '/')
		i--;
	i++;
	minipath = ft_substr(path, i, ft_strlen(path + i));
	free(path);
	path = ft_put_str_in_str("\001\e[36;1m\002minishell (\001\e[32;1m\002/\001\e[36;1m\002) \001\e[0m\002", minipath, 30);
	char *str = readline(path);
	return (str);
}

void	ft_init_sigint(void)
{
	struct sigaction sa;

	sa.sa_handler = &ft_ctrlc;
	sa.sa_flags = 0;
	sigemptyset(&(sa.sa_mask));
	sigaction(SIGINT, &sa, NULL);
}

void	ft_init_sigint_exec(void)
{
	struct sigaction sa;

	sa.sa_handler = &ft_ctrlc_exec;
	sigemptyset(&(sa.sa_mask));
	sa.sa_flags = 0;
	sigaction(SIGINT, &sa, NULL);
}

void	ft_init_sigint_hd(void)
{
	struct sigaction sa;

	sa.sa_handler = &ft_ctrlc_hd;
	sigemptyset(&(sa.sa_mask));
	sa.sa_flags = 0;
	sigaction(SIGINT, &sa, NULL);
}

void	ft_init_sigquit_exec(void)
{
	struct sigaction sa;

	sa.sa_handler = &ft_ctrlb_exec;
	sigemptyset(&(sa.sa_mask));
	sa.sa_flags = 0;
	sigaction(SIGQUIT, &sa, NULL);
}

void	ft_init_sigquit(void)
{
	struct sigaction sa;

	sa.sa_handler = SIG_IGN;
	sigemptyset(&(sa.sa_mask));
	sa.sa_flags = 0;
	sigaction(SIGQUIT, &sa, NULL);
}

int	main(int ac, char **av, char**envp)
{
	(void)ac;
	(void)av;
	(void)envp;
	char *str;
	t_data data;

	ft_init(envp, &data);
	ft_logo();
	ft_init_sigint();
	ft_init_sigquit();
	str = ft_prompt();
	add_history(str);
	while (str)
	{
		if (str && str[0])
		{
			str = ft_parse(str, &data);
			if (str)
			{
				ft_parse_for_exec(&data);
				ft_print_list(&data.exec);			
				ft_pipex(&data);
				ft_close_all(data.pip);
				ft_unlink_hd(&data.exec);
			}
			ft_init_sigint();
			ft_init_sigquit();

		}
		str = ft_prompt();
		add_history(str);
	}
	printf("\nexit\n");
	return (0);

#include "minishell.h"

extern t_data data;

static int	is_sep(char c, char *sep)
{
	size_t	i;

	i = 0;
	while (sep && i < ft_strlen(sep))
	{
		if (sep && c == sep[i])
			return (1);
		i++;
	}
	return (0);
	
}

static size_t	count_words_2(char const *s, char *sep)
{
	size_t	words;
	size_t	i;

	words = 0;
	i = 0;
	while (s[i])
	{
		if (!is_sep(s[i], sep) && (is_sep(s[i + 1], sep) || s[i + 1] == '\0'))
			words++;
		i++;
	}
	return (2*words - 1);
}

static void	fill_tab_2(char *new, char const *s, char *sep)
{
	size_t	i;

	i = 0;
	while (s[i] && !is_sep(s[i], sep))
	{
		new[i] = s[i];
		i++;
	}
	new[i] = '\0';
}

void	free_tabstr_2(char **tab)
{
	size_t	i;

	if (!tab)
		return ;
	i = 0;
	while (tab[i])
	{
		free(tab[i]);
		i++;
	}
	free(tab);
}

static int	set_mem_2(char **tab, char const *s, char *sep)
{
	size_t	count;
	size_t	index;
	size_t	i;

	index = 0;
	i = 0;
	while (s[index])
	{
		count = 0;
		while (s[index + count] && !is_sep(s[index + count], sep))
			count++;
		if (count > 0)
		{
			tab[i] = malloc(sizeof(char) * (count + 1));
			if (!tab[i])
				return (free_tabstr_2(tab), 0);
			fill_tab_2(tab[i], (s + index), sep);
			i++;
			index = index + count;
		}
		else if (is_sep(s[index], sep))
		{
			tab[i] = malloc(sizeof(char) * (3));
			if (!tab[i])
				return (free_tabstr_2(tab), 0);
			tab[i][0] = s[index];
			tab[i][1] = '\0';
			index++;
			i++;
		}
		else
			index++;
	}
	tab[i] = 0;
	return (0);
}

char	**ft_split_k(char const *s, char *sep)
{
	size_t	words;
	char	**tab;

	words = count_words_2(s, sep);
	tab = malloc(sizeof(char *) * (words + 1));
	if (!tab)
		return (NULL);
	set_mem_2(tab, s, sep);
	return (tab);
}

#include "minishell.h"

extern t_data data;

static int	is_sep_3(char c, char *sep)
{
	size_t	i;

	i = 0;
	while (sep && i < ft_strlen(sep))
	{
		if (sep && c == sep[i])
			return (1);
		i++;
	}
	return (0);
	
}

static size_t	count_words_3(char const *s, char *sep)
{
	size_t	words;
	size_t	i;

	words = 0;
	i = 0;
	while (s[i])
	{
		if (!is_sep_3(s[i], sep) && (is_sep_3(s[i + 1], sep) || s[i + 1] == '\0'))
			words++;
		i++;
	}
	return (2*words - 1);
}

static void	fill_tab_3(char *new, char const *s, char *sep)
{
	size_t	i;

	i = 0;
	while (s[i] && !is_sep_3(s[i], sep))
	{
		new[i] = s[i];
		i++;
	}
	new[i] = '\0';
}

void	free_tabstr_3(char **tab)
{
	size_t	i;

	if (!tab)
		return ;
	i = 0;
	while (tab[i])
	{
		free(tab[i]);
		i++;
	}
	free(tab);
}

static int	set_mem_3(char **tab, char const *s, char *sep)
{
	size_t	count;
	size_t	index;
	size_t	i;

	index = 0;
	i = 0;
	while (s[index])
	{
		count = 0;
		while (s[index + count] && !is_sep_3(s[index + count], sep))
			count++;
		if (count > 0)
		{
			tab[i] = malloc(sizeof(char) * (count + 1));
			if (!tab[i])
				return (free_tabstr_3(tab), 0);
			fill_tab_3(tab[i], (s + index), sep);
			i++;
			index = index + count;
		}
		else
			index++;
	}
	tab[i] = 0;
	return (0);
}

char	**ft_split_l(char const *s, char *sep)
{
	size_t	words;
	char	**tab;

	words = count_words_3(s, sep);
	tab = malloc(sizeof(char *) * (words + 1));
	if (!tab)
		return (NULL);
	set_mem_3(tab, s, sep);
	return (tab);
}

#include "minishell.h"

extern t_data data;

static int	is_sep_4(char c, char *sep)
{
	size_t	i;

	i = 0;
	while (sep && i < ft_strlen(sep))
	{
		if (sep && c == sep[i])
			return (1);
		i++;
	}
	return (0);
	
}
static void	ft_maj_quotes(int *dq, int *sq, char c)
{
	if (c == '"' && *sq == -1)
		*dq *= -1;
	if (c == '\'' && *dq == -1)
		*sq *= -1;
}
static size_t	count_words_4(char const *s, char *sep)
{
	size_t	words;
	size_t	i;
	int		sq;
	int		dq;

	words = 0;
	i = 0;
	sq = -1;
	dq = -1;
	while (s && s[i])
	{
		if (s[i] == '"' || s[i] == '\'')
			ft_maj_quotes(&dq, &sq, s[i]);
		if ((dq == -1 && sq == -1) && (!is_sep_4(s[i], sep) && (is_sep_4(s[i + 1], sep) || s[i + 1] == '\0')))
			words++;
		i++;
	}
	return (words);
}

static void	fill_tab_4(char *new, char const *s, int len)
{
	int	i;

	i = 0;
	while (i < len)
	{
		new[i] = s[i];
		i++;
	}
	new[i] = '\0';
}

void	free_tabstr_4(char **tab)
{
	size_t	i;

	if (!tab)
		return ;
	i = 0;
	while (tab[i])
	{
		free(tab[i]);
		i++;
	}
	free(tab);
}

static int	set_mem_4(char **tab, char const *s, char *sep)
{
	size_t	count;
	size_t	index;
	size_t	i;
	int dq;
	int sq;

	index = 0;
	i = 0;
	dq = -1;
	sq = -1;
	while (s && s[index])
	{
		count = 0;
		if (s[index] == '\'' || s[index] == '"')
				ft_maj_quotes(&dq, &sq, s[index]);
		while (s[index + count] && (dq == 1 || sq == 1 || (!is_sep_4(s[index + count], sep))))
		{
			count++;
			if (s[index + count] == '\'' || s[index + count] == '"')
				ft_maj_quotes(&dq, &sq, s[index + count]);
		}
		if (count > 0)
		{
			tab[i] = malloc(sizeof(char) * (count + 1));
			if (!tab[i])
				return (free_tabstr_4(tab), 0);
			fill_tab_4(tab[i], (s + index), count);
			i++;
			index = index + count;
		}
		else
			index++;
	}
	tab[i] = 0;
	return (0);
}

char	**ft_split_lq(char const *s, char *sep)
{
	size_t	words;
	char	**tab;

	words = count_words_4(s, sep);
	tab = malloc(sizeof(char *) * (words + 1));
	if (!tab)
		return (NULL);
	set_mem_4(tab, s, sep);
	return (tab);
}
#include "../_Include/minishell.h"

int	ft_strstrlen(char **strstr)
{
	int	i;

	i = 0;
	while (strstr && strstr[i])
	{
		i++;
	}
	return (i);	
}

char *ft_put_str_in_str(char *dest, char *src, int ind)
{
	int 	i;
	size_t	len;
	char	*output;
	size_t		j;
	int		k;

	len = ft_strlen(dest) + ft_strlen(src);
	output = malloc(sizeof(char) * len + 1);
	if (!output)
	i = 0;
	j = 0;
	k = 0;
	while (j < len)
	{
		if (ind == i && src && src[k])
			output[j++] = src[k++];
		else
			output[j++] = dest[i++];
	}
	output[j] = '\0';
	return (output);
}

char *ft_tab_to_str(char **tab, char sep)
{
	int i;
	int len;
	int j;
	int k;
	char *str;

	i = -1;
	j = 0;
	len = 0;
	while (tab[++i])
		len += ft_strlen(tab[i]);
	len += i - 1;
	str = malloc(sizeof(char) * len + 1);
	if (!str)
		return (NULL);
	str[len] = '\0';
	i = 0;
	k = 0;
	while (tab[i])
	{
		j = 0;
		while(tab[i][j])
		{
			str[k] = tab[i][j];
			j++;
			k++;

		}
		if (k < len)
		{
			str[k] = sep;
			k++;
		}
		i++;
	}
	return (str);
}#include "../_Include/minishell.h"

void	ft_free_dchar(char **str)
{
	int	i;

	i = 0;
	while (str && str[i])
	{
		free(str[i]);
		i++;
	}
	if (str)
		free(str);
}

static void    ft_strrjoin_bis(char *new, char const *s3)
{
    size_t    i;

    i = 0;
    while (s3 && s3[i])
    {
        new[i] = s3[i];
        i++;
    }
    new[i] = '\0';
}

char    *ft_strrjoin(char const *s1, char const *s2, char const *s3)
{
    char    *new;
    size_t    i;
    size_t    j;

    if (!s1 && !s2 && !s3)
        return (NULL);
    new = malloc(sizeof(char) * \
        (ft_strlen(s1) + ft_strlen(s2) + ft_strlen(s3) + 1));
    if (!new)
        return (NULL);
    i = 0;
    while (s1 && s1[i])
    {
        new[i] = s1[i];
        i++;
    }
    j = 0;
    while (s2 && s2[j])
    {
        new[i + j] = s2[j];
        j++;
    }
    ft_strrjoin_bis(new + i + j, s3);
    return (new);
}

void    ft_close_all(t_pip pip)
{
    ft_close(&pip.fd_in);
    ft_close(&pip.fd_out);
    ft_close(&pip.pipefd1[0]);
    ft_close(&pip.pipefd1[1]);
    ft_close(&pip.pipefd2[0]);
    ft_close(&pip.pipefd2[1]);

#ifndef GET_NEXT_LINE_H

# define GET_NEXT_LINE_H

# ifndef BUFFER_SIZE
#  define BUFFER_SIZE 42
# endif

# include <stdlib.h>
# include <unistd.h>
# include <fcntl.h>
# include <stdio.h>

typedef struct s_bufferList
{
	char				*content;
	struct s_bufferList	*next;	
}						t_bufferList;

typedef struct s_fdList
{
	int					fd;
	t_bufferList		*begin;
	struct s_fdList		*next_fd;	
}					t_fdList;

char			*get_next_line(int fd);

t_bufferList	*ftlst_new_buffer(void);
t_fdList		*ftlst_new_fd(int fd);
int				end_of_line(char *content);
size_t			count_memory(t_bufferList *current);
t_fdList		*clean_fd_list(t_fdList *fd_list, t_fdList *current);


#ifndef SUPERLIBFT_H
# define SUPERLIBFT_H

# include <stdio.h>
# include <unistd.h>
# include <stdlib.h>
# include <string.h>
# include <stddef.h>
# include <ctype.h>
# include <sys/types.h>
# include <sys/stat.h>
# include <fcntl.h>
# include <stdarg.h>
# include <limits.h> 
# include "get_next_line.h" 




# ifndef BUFFER_SIZE
#  define BUFFER_SIZE 42
# endif

typedef struct s_list
{
	void			*content;
	struct s_list	*next;
}					t_list;


int		ft_atoi(const char *str);
void	ft_bzero(void *s, size_t n);
void	*ft_calloc(size_t nitems, size_t size);
int		ft_isalnum(int str);
int		ft_isalpha(int str);
int		ft_isascii(int str);
int		ft_isdigit(int str);
int		ft_isprint(int str);
char	*ft_itoa(int n);
void	*ft_memchr(const void *s, int c, size_t n);
void	*ft_memcpy(void *dest, const void *src, size_t n);
void	*ft_memmove(void *dest, const void *src, size_t n);
void	*ft_memset(void *b, int c, size_t len);
void	ft_putchar_fd(char c, int fd);
void	ft_putendl_fd(char *s, int fd);
void	ft_putnbr_fd(int n, int fd);
void	ft_putstr_fd(char *s, int fd);
char	**ft_split(char const *str, char c);
char	*ft_strchr(char *str, int lettre);
char	*ft_strdup(char *str);
void	ft_striteri(char *s, void (*f)(unsigned int, char*));
char	*ft_strjoin(char const *s1, char const *s2);
char	*ft_strrchr(const char *str, int lettre);
size_t	ft_strlcat(char *dst, const char *src, size_t dstsize);
size_t	ft_strlcpy(char *dst, const char *src, size_t size);
size_t	ft_strlen(const char *str);
char	*ft_strmapi(char const *s, char (*f)(unsigned int, char));
int		ft_strncmp(const char *s1, const char *s2, size_t n);
char	*ft_strtrim(char const *s1, char const *set);
char	*ft_substr(char const *s, unsigned int start, size_t len);
int		ft_tolower(int character);
int		ft_toupper( int character );
char	*ft_strnstr(const char *src, const char *cmp, size_t n);
int		ft_memcmp(const void *s1, const void *s2, size_t n);
t_list	*ft_lstnew(void *content);
void	ft_lstadd_front(t_list **lst, t_list *new);
int		ft_lstsize(t_list *lst);
t_list	*ft_lstlast(t_list *lst);
void	ft_lstadd_back(t_list **lst, t_list *new);
void	ft_lstdelone(t_list *lst, void (*del)(void*));
void	ft_lstclear(t_list **lst, void (*del)(void*));
void	ft_lstiter(t_list *lst, void (*f)(void *));
t_list	*ft_lstmap(t_list *lst, void *(*f)(void *), void (*del)(void *));
char	*ft_strrjoin(char const *s1, char const *s2, char const *s3);
char	*ft_randomstr(char *prefix, char *suffix, size_t len);


char			*get_next_line(int fd);

t_bufferList	*ftlst_new_buffer(void);
t_fdList		*ftlst_new_fd(int fd);
int				end_of_line(char *content);
size_t			count_memory(t_bufferList *current);
t_fdList		*clean_fd_list(t_fdList *fd_list, t_fdList *current);

int		ft_writechar(char ch, int nbrch);
int		ft_writestr(char *str, int nbrch);
int		ft_print_pourcent(const char *str, int nbrch, va_list *list);
int		ft_printf(const char *str, ...);
int		ft_pc_id(int nbr, int nbrch);
void	ft_putnbr_pc_id(int nb);
void	ft_putchar_pc_idu(char c);
int		ft_pc_p(unsigned long nbr, int nbrch);
int		ft_print_pc_p_base(unsigned long nbr, int nbrch);
int		ft_len_nbr_pc_p(unsigned long nbr, int nbrch);
int		ft_pc_u(unsigned int nbr, int nbrch);
void	ft_putnbr_pc_u(unsigned int nb);
int		ft_pc_x(long nbr, char *base, int nbrch);
int		ft_len_nbr_pc_x(unsigned int nbr, int nbrch);
void	ft_print_base_pc_x(unsigned int nbr, char *base);

int		ft_strcmp(const char *s1, const char *s2);
#endif